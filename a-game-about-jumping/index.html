<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Game About Jumping</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
        }
        #gameWrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #gameCanvas {
            display: block;
            background: #16213e;
        }
        #levelDisplay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 8px 16px;
            color: #7dd3fc;
            font-size: 16px;
            font-weight: bold;
            display: none;
        }
        #timerDisplay {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 8px 20px;
            color: #fcd34d;
            font-size: 20px;
            font-weight: bold;
            font-family: monospace;
            display: none;
        }
        #leaderboard {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 102;
        }
        #leaderboard h2 {
            color: #fcd34d;
            font-size: 36px;
            margin-bottom: 20px;
        }
        .leaderboard-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            min-width: 350px;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
        }
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        .leaderboard-entry .rank {
            color: #7dd3fc;
            font-weight: bold;
            width: 30px;
        }
        .leaderboard-entry .name {
            flex: 1;
            margin-left: 10px;
        }
        .leaderboard-entry .time {
            color: #fcd34d;
            font-family: monospace;
            font-weight: bold;
        }
        .leaderboard-entry.gold .rank { color: #fcd34d; }
        .leaderboard-entry.silver .rank { color: #c0c0c0; }
        .leaderboard-entry.bronze .rank { color: #cd7f32; }
        .no-entries {
            color: #888;
            text-align: center;
            padding: 20px;
        }
        #customize {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 102;
        }
        #customize h2 {
            color: #f472b6;
            font-size: 36px;
            margin-bottom: 20px;
        }
        .player-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .player-tab {
            padding: 10px 30px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            transition: all 0.2s;
        }
        .player-tab:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .player-tab.selected {
            border-color: #f472b6;
            background: rgba(244, 114, 182, 0.3);
        }
        .customize-content {
            display: flex;
            gap: 40px;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 20px;
        }
        .character-preview {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        #previewCanvas {
            display: block;
        }
        .customize-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .color-option {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .color-option label {
            color: #fff;
            font-size: 16px;
            width: 100px;
        }
        .color-option input[type="color"] {
            width: 60px;
            height: 35px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: none;
        }
        .color-option input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }
        .color-option input[type="color"]::-webkit-color-swatch {
            border-radius: 3px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .preset-colors {
            margin-top: 10px;
        }
        .preset-colors label {
            color: #fff;
            font-size: 16px;
            display: block;
            margin-bottom: 10px;
        }
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .preset-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            transition: background 0.2s;
        }
        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .accessory-section {
            margin-top: 15px;
        }
        .accessory-section label {
            color: #fff;
            font-size: 16px;
            display: block;
            margin-bottom: 10px;
        }
        .accessory-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .accessory-btn {
            padding: 8px 12px;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            transition: all 0.2s;
        }
        .accessory-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .accessory-btn.selected {
            border-color: #f472b6;
            background: rgba(244, 114, 182, 0.3);
        }
        #nameEntry {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 103;
        }
        #nameEntry h2 {
            color: #22c55e;
            font-size: 36px;
            margin-bottom: 10px;
        }
        #nameEntry .final-time {
            color: #fcd34d;
            font-size: 48px;
            font-family: monospace;
            font-weight: bold;
            margin-bottom: 30px;
        }
        #nameEntry p {
            color: #ccc;
            margin-bottom: 15px;
        }
        #nameEntry input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #7dd3fc;
            border-radius: 10px;
            padding: 12px 20px;
            color: #fff;
            font-size: 18px;
            text-align: center;
            width: 250px;
            margin-bottom: 20px;
        }
        #nameEntry input:focus {
            outline: none;
            border-color: #fcd34d;
        }
        #nameEntry .btn-row {
            display: flex;
            gap: 15px;
        }
        #musicBtn {
            position: absolute;
            top: 15px;
            right: 120px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 8px 16px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: none;
        }
        #musicBtn:hover {
            background: rgba(99, 102, 241, 0.7);
            border-color: #7dd3fc;
        }
        #musicBtn.on {
            background: rgba(34, 197, 94, 0.7);
            border-color: #22c55e;
        }
        #escBtn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 8px 16px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: none;
            transition: all 0.2s;
        }
        #escBtn:hover {
            background: rgba(59, 130, 246, 0.7);
            border-color: #7dd3fc;
        }
        #escBtn span {
            color: #7dd3fc;
            margin-right: 5px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            border: 3px solid #7dd3fc;
            border-radius: 20px;
            padding: 30px 50px;
            color: #fff;
            text-align: center;
            display: none;
        }
        #message h2 {
            color: #7dd3fc;
            margin-bottom: 15px;
            font-size: 28px;
        }
        #message p {
            margin-bottom: 20px;
            color: #ccc;
        }
        #message button {
            background: linear-gradient(135deg, #7dd3fc, #3b82f6);
            border: none;
            padding: 12px 30px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }
        #message button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
        }
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
            z-index: 100;
        }
        #mainMenu h1 {
            color: #7dd3fc;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(125, 211, 252, 0.5);
        }
        #mainMenu .subtitle {
            color: #888;
            font-size: 16px;
            margin-bottom: 25px;
        }
        .menu-btn {
            background: linear-gradient(135deg, #7dd3fc, #3b82f6);
            border: none;
            padding: 12px 50px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 6px;
            min-width: 220px;
        }
        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(125, 211, 252, 0.6);
        }
        .menu-btn.secondary {
            background: linear-gradient(135deg, #4a5568, #2d3748);
        }
        #howToPlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 101;
            padding: 40px;
        }
        #howToPlay h2 {
            color: #7dd3fc;
            font-size: 36px;
            margin-bottom: 30px;
        }
        #howToPlay .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px 60px;
            margin-bottom: 30px;
        }
        #howToPlay .control-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #howToPlay .key {
            background: #3b82f6;
            color: #fff;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
        }
        #howToPlay .desc {
            color: #ccc;
            font-size: 16px;
        }
        #howToPlay .tips {
            color: #888;
            font-size: 14px;
            max-width: 500px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
        }
        #howToPlay .tips span {
            color: #fcd34d;
        }
        #editorPanel {
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            padding: 8px 15px;
            margin-top: 10px;
            display: none;
            width: 960px;
        }
        .editor-toolbar {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .toolbar-section-label {
            color: #7dd3fc;
            font-size: 10px;
            font-weight: bold;
            margin-right: 5px;
        }
        .toolbar-divider {
            width: 1px;
            height: 30px;
            background: #4a5568;
            margin: 0 5px;
        }
        #editorPanel h3 {
            display: none;
        }
        #editorPanel .tool-grid {
            display: flex;
            gap: 3px;
        }
        .tool-btn {
            background: #2d3748;
            border: 2px solid #4a5568;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }
        .tool-btn:hover, .tool-btn.active {
            background: #3b82f6;
            border-color: #7dd3fc;
        }
        .editor-actions {
            display: flex;
            gap: 3px;
        }
        .editor-actions button {
            background: #4a5568;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
        .editor-actions button:hover {
            background: #3b82f6;
        }
        .editor-actions button.danger {
            background: #dc2626;
        }
        .your-levels {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0;
            padding: 0;
            border: none;
        }
        .your-levels h4 {
            display: none;
        }
        .level-list {
            display: flex;
            gap: 3px;
            max-width: 250px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 2px;
        }
        .level-item {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #2d3748;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .level-item.active {
            background: #3b82f6;
        }
        .level-item span {
            color: #fff;
            flex: 1;
            cursor: pointer;
        }
        .level-item-btns {
            display: flex;
            gap: 2px;
        }
        .level-item-btns button {
            background: #4a5568;
            border: none;
            color: #fff;
            padding: 2px 5px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 9px;
        }
        .level-item-btns button:hover {
            background: #6366f1;
        }
        .level-item-btns button.delete:hover {
            background: #dc2626;
        }
        .new-level-row {
            display: flex;
            gap: 3px;
        }
        .new-level-row input {
            width: 100px;
            background: #2d3748;
            border: 1px solid #4a5568;
            color: #fff;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        .new-level-row input:focus {
            outline: none;
            border-color: #7dd3fc;
        }
        .new-level-row button {
            background: #22c55e;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
        .new-level-row button:hover {
            background: #16a34a;
        }
        .new-level-btn {
            background: #6366f1;
            border: none;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
        }
        .new-level-btn:hover {
            background: #4f46e5;
        }
        .editor-actions button.success {
            background: #22c55e;
        }
        #levelCodeModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 104;
            padding: 40px;
        }
        #levelCodeModal h2 {
            color: #7dd3fc;
            font-size: 24px;
            margin-bottom: 15px;
        }
        #levelCodeModal p {
            color: #888;
            font-size: 12px;
            margin-bottom: 10px;
        }
        #levelCodeModal textarea {
            width: 80%;
            max-width: 600px;
            height: 300px;
            background: #1a1a2e;
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            padding: 15px;
            resize: none;
            margin-bottom: 15px;
        }
        #levelCodeModal textarea:focus {
            outline: none;
            border-color: #7dd3fc;
        }
        #levelCodeModal .btn-row {
            display: flex;
            gap: 10px;
        }
        .copy-btns {
            display: flex;
            gap: 3px;
        }
        .copy-btn {
            background: #7c3aed;
            border: none;
            color: #fff;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
        .copy-btn:hover {
            background: #6d28d9;
        }
        .import-btn {
            background: #0891b2;
            border: none;
            color: #fff;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
        .import-btn:hover {
            background: #0e7490;
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
    <div id="gameContainer">
        <canvas id="gameCanvas" width="960" height="640"></canvas>
        <div id="levelDisplay">Level 1</div>
        <div id="timerDisplay">00:00.000</div>
        <div id="musicBtn">Music: OFF</div>
        <div id="escBtn"><span>ESC</span> Back</div>
        <div id="message">
            <h2 id="messageTitle">Level Complete!</h2>
            <p id="messageText">Press the button to continue</p>
            <button id="messageBtn">Continue</button>
        </div>
        <div id="mainMenu">
            <h1>A Game About Jumping</h1>
            <p class="subtitle">A platformer adventure</p>
            <button class="menu-btn" id="playBtn">Play</button>
            <button class="menu-btn" id="twoPlayerBtn">2 Player</button>
            <button class="menu-btn" id="chainedBtn">Chained Together</button>
            <button class="menu-btn secondary" id="editorBtn">Level Builder</button>
            <button class="menu-btn secondary" id="leaderboardBtn">Leaderboard</button>
            <button class="menu-btn secondary" id="customizeBtn">Customize</button>
            <button class="menu-btn secondary" id="howToPlayBtn">How to Play</button>
        </div>
        <div id="customize">
            <h2>Customize Character</h2>
            <div class="player-tabs">
                <button class="player-tab selected" id="p1Tab">Player 1</button>
                <button class="player-tab" id="p2Tab">Player 2</button>
            </div>
            <div class="customize-content">
                <div class="character-preview">
                    <canvas id="previewCanvas" width="100" height="120"></canvas>
                </div>
                <div class="customize-options">
                    <div class="color-option">
                        <label>Body Color</label>
                        <input type="color" id="bodyColor" value="#3b82f6">
                    </div>
                    <div class="color-option">
                        <label>Skin Color</label>
                        <input type="color" id="skinColor" value="#f5c49c">
                    </div>
                    <div class="color-option">
                        <label>Eye Color</label>
                        <input type="color" id="eyeColor" value="#1e3a5f">
                    </div>
                    <div class="preset-colors">
                        <label>Presets</label>
                        <div class="preset-buttons">
                            <button class="preset-btn" data-body="#3b82f6" data-skin="#f5c49c" data-eye="#1e3a5f">Default</button>
                            <button class="preset-btn" data-body="#ef4444" data-skin="#f5c49c" data-eye="#1e3a5f">Red</button>
                            <button class="preset-btn" data-body="#22c55e" data-skin="#f5c49c" data-eye="#1e3a5f">Green</button>
                            <button class="preset-btn" data-body="#a855f7" data-skin="#f5c49c" data-eye="#1e3a5f">Purple</button>
                            <button class="preset-btn" data-body="#f59e0b" data-skin="#f5c49c" data-eye="#1e3a5f">Orange</button>
                            <button class="preset-btn" data-body="#1e1e1e" data-skin="#f5c49c" data-eye="#ef4444">Shadow</button>
                        </div>
                    </div>
                    <div class="accessory-section">
                        <label>Hats</label>
                        <div class="accessory-buttons">
                            <button class="accessory-btn selected" data-accessory="none">None</button>
                            <button class="accessory-btn" data-accessory="cowboy">Cowboy Hat</button>
                            <button class="accessory-btn" data-accessory="tophat">Top Hat</button>
                            <button class="accessory-btn" data-accessory="baseball">Baseball Cap</button>
                            <button class="accessory-btn" data-accessory="beanie">Beanie</button>
                            <button class="accessory-btn" data-accessory="party">Party Hat</button>
                            <button class="accessory-btn" data-accessory="crown">Crown</button>
                        </div>
                    </div>
                    <div class="accessory-section">
                        <label>Face</label>
                        <div class="accessory-buttons">
                            <button class="accessory-btn" data-accessory="visor">Techno Visor</button>
                            <button class="accessory-btn" data-accessory="headband">Headband</button>
                            <button class="accessory-btn" data-accessory="sunglasses">Sunglasses</button>
                        </div>
                    </div>
                </div>
            </div>
            <button class="menu-btn" id="backFromCustomize">Save & Back</button>
        </div>
        <div id="leaderboard">
            <h2>Leaderboard</h2>
            <div class="leaderboard-list" id="leaderboardList"></div>
            <button class="menu-btn" id="backFromLeaderboard">Back to Menu</button>
        </div>
        <div id="nameEntry">
            <h2>Run Complete!</h2>
            <div class="final-time" id="finalTime">00:00.000</div>
            <p>Enter your name for the leaderboard:</p>
            <input type="text" id="playerName" placeholder="Your name..." maxlength="20">
            <div class="btn-row">
                <button class="menu-btn" id="saveScoreBtn">Save Score</button>
                <button class="menu-btn secondary" id="skipScoreBtn">Skip</button>
            </div>
        </div>
        <div id="howToPlay">
            <h2>How to Play</h2>
            <div class="controls-grid">
                <div class="control-item">
                    <span class="key">A / D</span>
                    <span class="desc">Move left / right</span>
                </div>
                <div class="control-item">
                    <span class="key">Arrows</span>
                    <span class="desc">Move left / right</span>
                </div>
                <div class="control-item">
                    <span class="key">W / Space</span>
                    <span class="desc">Jump</span>
                </div>
                <div class="control-item">
                    <span class="key">Up Arrow</span>
                    <span class="desc">Jump</span>
                </div>
            </div>
            <div class="tips">
                <span>Wall Jump:</span> Slide down a wall and press jump to leap off it.<br><br>
                <span>Goal:</span> Reach the green flag to complete each level.<br><br>
                <span>Enemies:</span> Jump on them to defeat them, or avoid them!<br><br>
                <span>Hazards:</span> Avoid spikes and lava - they're instant death!
            </div>
            <button class="menu-btn" id="backFromHowTo">Back to Menu</button>
        </div>
    </div>
    <div id="editorPanel">
            <div class="editor-toolbar">
                <div class="toolbar-section">
                    <span class="toolbar-section-label">Tools:</span>
                    <div class="tool-grid">
                        <button class="tool-btn active" data-tool="platform">Platform</button>
                        <button class="tool-btn" data-tool="moving">Moving</button>
                        <button class="tool-btn" data-tool="sticky">Sticky</button>
                        <button class="tool-btn" data-tool="bouncy">Bouncy</button>
                        <button class="tool-btn" data-tool="spike">Spike</button>
                        <button class="tool-btn" data-tool="lava">Lava</button>
                        <button class="tool-btn" data-tool="enemy">Enemy</button>
                        <button class="tool-btn" data-tool="flag">Flag</button>
                        <button class="tool-btn" data-tool="spawn">Spawn</button>
                        <button class="tool-btn" data-tool="erase">Erase</button>
                    </div>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section" id="movingSettings" style="display:none;">
                    <span class="toolbar-section-label">Moving Platform:</span>
                    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                        <label style="color:#aaa; font-size:12px;">Range: <input type="number" id="mpRange" value="80" min="20" max="400" style="width:60px;"></label>
                        <label style="color:#aaa; font-size:12px;">Speed: <input type="number" id="mpSpeed" value="2" min="0.5" max="10" step="0.5" style="width:60px;"></label>
                        <label style="color:#aaa; font-size:12px;"><input type="checkbox" id="mpVertical"> Vertical</label>
                    </div>
                    <div id="selectedMpInfo" style="color:#7dd3fc; font-size:11px; margin-top:5px;"></div>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section">
                    <span class="toolbar-section-label">Actions:</span>
                    <div class="editor-actions">
                        <button id="testLevelBtn" class="success">Test</button>
                        <button id="clearLevelBtn" class="danger">Clear</button>
                        <button id="backToMenuBtn">Menu</button>
                    </div>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section your-levels">
                    <span class="toolbar-section-label">Levels:</span>
                    <div class="level-list" id="levelList"></div>
                    <div class="new-level-row">
                        <input type="text" id="newLevelName" placeholder="Name...">
                        <button id="saveLevelBtn">Save</button>
                    </div>
                    <button id="newLevelBtn" class="new-level-btn">+ New</button>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section">
                    <span class="toolbar-section-label">Share:</span>
                    <div class="copy-btns">
                        <button id="copyLevelBtn" class="copy-btn">Copy Code</button>
                        <button id="importLevelBtn" class="import-btn">Import</button>
                    </div>
                </div>
            </div>
    </div>
    </div>
    <div id="levelCodeModal">
            <h2 id="levelCodeTitle">Level Code</h2>
            <p id="levelCodeDesc">Copy this code to share your level, or paste code to import a level.</p>
            <textarea id="levelCodeText" spellcheck="false"></textarea>
            <div class="btn-row">
                <button class="menu-btn" id="copyToClipboardBtn">Copy to Clipboard</button>
                <button class="menu-btn secondary" id="importFromCodeBtn" style="display:none;">Import Level</button>
                <button class="menu-btn secondary" id="closeLevelCodeBtn">Close</button>
            </div>
        </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelDisplay = document.getElementById('levelDisplay');
        const message = document.getElementById('message');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const messageBtn = document.getElementById('messageBtn');
        const mainMenu = document.getElementById('mainMenu');
        const howToPlay = document.getElementById('howToPlay');
        const editorPanel = document.getElementById('editorPanel');
        const escBtn = document.getElementById('escBtn');
        const gameContainer = document.getElementById('gameContainer');

        function showEditor() {
            editorPanel.style.display = 'block';
        }
        function hideEditor() {
            editorPanel.style.display = 'none';
        }

        // Game constants
        const TILE_SIZE = 32;
        const GRAVITY = 0.6;
        const FRICTION = 0.85;
        const MAX_FALL_SPEED = 15;

        // Audio system
        let audioCtx = null;
        let musicPlaying = false;
        let masterGain = null;
        let musicGain = null;
        let sfxGain = null;
        let nextNoteTime = 0;
        let musicInterval = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.5;
                masterGain.connect(audioCtx.destination);
                musicGain = audioCtx.createGain();
                musicGain.gain.value = 0.3;
                musicGain.connect(masterGain);
                sfxGain = audioCtx.createGain();
                sfxGain.gain.value = 0.5;
                sfxGain.connect(masterGain);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Ensure audio is initialized on first user interaction
        document.addEventListener('click', function firstClick() {
            initAudio();
            document.removeEventListener('click', firstClick);
        }, { once: true });

        function playJumpSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(sfxGain || audioCtx.destination);

            osc.type = 'square';
            osc.frequency.setValueAtTime(250, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);

            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.15);
        }

        function playWallJumpSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(sfxGain || audioCtx.destination);

            osc.type = 'square';
            osc.frequency.setValueAtTime(300, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.08);
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.12);

            gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.15);
        }

        function playDeathSound() {
            if (!audioCtx) return;
            // Descending tone
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(sfxGain || audioCtx.destination);

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.4);

            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.5);

            // Noise burst
            const bufferSize = audioCtx.sampleRate * 0.2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            }
            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain);
            noiseGain.connect(sfxGain || audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            noise.start(audioCtx.currentTime);
        }

        function playLevelCompleteSound() {
            if (!audioCtx) return;
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(sfxGain || audioCtx.destination);
                osc.type = 'square';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.1 + 0.3);
                osc.start(audioCtx.currentTime + i * 0.1);
                osc.stop(audioCtx.currentTime + i * 0.1 + 0.3);
            });
        }

        // Techno music generator
        const bassPattern = [1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0];
        const kickPattern = [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0];
        const hihatPattern = [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1];
        const melodyNotes = [261, 329, 392, 329, 293, 349, 392, 440, 261, 329, 392, 523, 440, 392, 349, 329];
        let beatIndex = 0;

        function playBeat() {
            if (!audioCtx || !musicPlaying) return;

            const time = audioCtx.currentTime;

            // Kick drum
            if (kickPattern[beatIndex]) {
                const kick = audioCtx.createOscillator();
                const kickGain = audioCtx.createGain();
                kick.connect(kickGain);
                kickGain.connect(musicGain);
                kick.type = 'sine';
                kick.frequency.setValueAtTime(150, time);
                kick.frequency.exponentialRampToValueAtTime(30, time + 0.1);
                kickGain.gain.setValueAtTime(0.5, time);
                kickGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                kick.start(time);
                kick.stop(time + 0.15);
            }

            // Hi-hat
            if (hihatPattern[beatIndex]) {
                const bufferSize = audioCtx.sampleRate * 0.05;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }
                const hihat = audioCtx.createBufferSource();
                const hihatGain = audioCtx.createGain();
                const hihatFilter = audioCtx.createBiquadFilter();
                hihat.buffer = buffer;
                hihatFilter.type = 'highpass';
                hihatFilter.frequency.value = 7000;
                hihat.connect(hihatFilter);
                hihatFilter.connect(hihatGain);
                hihatGain.connect(musicGain);
                hihatGain.gain.setValueAtTime(0.15, time);
                hihat.start(time);
            }

            // Bass
            if (bassPattern[beatIndex]) {
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.connect(bassGain);
                bassGain.connect(musicGain);
                bass.type = 'sawtooth';
                bass.frequency.value = 55;
                bassGain.gain.setValueAtTime(0.2, time);
                bassGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                bass.start(time);
                bass.stop(time + 0.12);
            }

            // Melody (every 2 beats)
            if (beatIndex % 2 === 0) {
                const melody = audioCtx.createOscillator();
                const melodyGain = audioCtx.createGain();
                melody.connect(melodyGain);
                melodyGain.connect(musicGain);
                melody.type = 'square';
                melody.frequency.value = melodyNotes[Math.floor(beatIndex / 2) % melodyNotes.length];
                melodyGain.gain.setValueAtTime(0.08, time);
                melodyGain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                melody.start(time);
                melody.stop(time + 0.18);
            }

            beatIndex = (beatIndex + 1) % 16;
        }

        function startMusic() {
            if (musicPlaying) return;
            initAudio();
            musicPlaying = true;
            beatIndex = 0;
            musicInterval = setInterval(playBeat, 125); // 120 BPM
        }

        function stopMusic() {
            musicPlaying = false;
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
        }

        function toggleMusic() {
            if (musicPlaying) {
                stopMusic();
            } else {
                startMusic();
            }
        }

        // Speedrun timer
        let speedrunStartTime = 0;
        let speedrunTime = 0;
        let speedrunRunning = false;
        // JSONBin.io config â€” paste your API key and bin ID here
        const JSONBIN_API_KEY = '$2a$10$tyfs0LWbj9I/b8WxxsMNlO/D.hC9luKCiojV96msYeFxwp3bdmreO';
        const JSONBIN_BIN_ID = '6989ff27d0ea881f40ad6831';

        let leaderboardData = JSON.parse(localStorage.getItem('jumpGameLeaderboard') || '[]');


        // Character customization
        const defaultCustomization = {
            bodyColor: '#3b82f6',
            skinColor: '#f5c49c',
            eyeColor: '#1e3a5f',
            accessory: 'none'
        };

        const defaultP2Customization = {
            bodyColor: '#ec4899',
            skinColor: '#fcd5ce',
            eyeColor: '#831843',
            accessory: 'none'
        };

        let characterCustomization = JSON.parse(localStorage.getItem('jumpGameCustomization')) || { ...defaultCustomization };
        let player2Customization = JSON.parse(localStorage.getItem('jumpGameP2Customization')) || { ...defaultP2Customization };

        // Ensure accessory property exists for old saves
        if (!characterCustomization.accessory) characterCustomization.accessory = 'none';
        if (!player2Customization.accessory) player2Customization.accessory = 'none';

        let editingPlayer = 1; // 1 or 2, which player is being customized

        function saveCustomization() {
            localStorage.setItem('jumpGameCustomization', JSON.stringify(characterCustomization));
            localStorage.setItem('jumpGameP2Customization', JSON.stringify(player2Customization));
        }

        function getCurrentCustomization() {
            return editingPlayer === 1 ? characterCustomization : player2Customization;
        }

        function setCurrentCustomization(prop, value) {
            if (editingPlayer === 1) {
                characterCustomization[prop] = value;
            } else {
                player2Customization[prop] = value;
            }
        }

        function lightenColor(hex, percent) {
            const num = parseInt(hex.slice(1), 16);
            const r = Math.min(255, (num >> 16) + Math.round(255 * percent));
            const g = Math.min(255, ((num >> 8) & 0x00FF) + Math.round(255 * percent));
            const b = Math.min(255, (num & 0x0000FF) + Math.round(255 * percent));
            return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`;
        }

        function darkenColor(hex, percent) {
            const num = parseInt(hex.slice(1), 16);
            const r = Math.max(0, (num >> 16) - Math.round(255 * percent));
            const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.round(255 * percent));
            const b = Math.max(0, (num & 0x0000FF) - Math.round(255 * percent));
            return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`;
        }

        function drawAccessory(ctx, px, py, pw, accessory, facingRight = true) {
            const headCenterX = px + pw / 2;
            const headTopY = py - 2;

            switch (accessory) {
                case 'cowboy':
                    // Cowboy hat
                    ctx.fillStyle = '#8B4513';
                    // Brim
                    ctx.beginPath();
                    ctx.ellipse(headCenterX, headTopY + 2, 14, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Crown
                    ctx.fillRect(headCenterX - 7, headTopY - 8, 14, 10);
                    ctx.fillStyle = '#654321';
                    // Band
                    ctx.fillRect(headCenterX - 7, headTopY - 2, 14, 3);
                    break;

                case 'visor':
                    // Techno visor
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 8;
                    ctx.fillRect(headCenterX - 10, py + 4, 20, 5);
                    ctx.shadowBlur = 0;
                    // Frame
                    ctx.fillStyle = '#333';
                    ctx.fillRect(headCenterX - 12, py + 3, 2, 7);
                    ctx.fillRect(headCenterX + 10, py + 3, 2, 7);
                    break;

                case 'crown':
                    // Crown
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(headCenterX - 8, headTopY + 2);
                    ctx.lineTo(headCenterX - 8, headTopY - 4);
                    ctx.lineTo(headCenterX - 4, headTopY);
                    ctx.lineTo(headCenterX, headTopY - 6);
                    ctx.lineTo(headCenterX + 4, headTopY);
                    ctx.lineTo(headCenterX + 8, headTopY - 4);
                    ctx.lineTo(headCenterX + 8, headTopY + 2);
                    ctx.closePath();
                    ctx.fill();
                    // Jewels
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(headCenterX, headTopY - 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'headband':
                    // Headband
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(headCenterX - 10, py + 1, 20, 4);
                    // Knot on side
                    const knotX = facingRight ? headCenterX + 8 : headCenterX - 12;
                    ctx.fillRect(knotX, py - 2, 4, 6);
                    ctx.fillRect(knotX - 1, py + 5, 6, 8);
                    break;

                case 'sunglasses':
                    // Sunglasses
                    ctx.fillStyle = '#1a1a1a';
                    // Left lens
                    ctx.beginPath();
                    ctx.roundRect(headCenterX - 10, py + 3, 8, 6, 2);
                    ctx.fill();
                    // Right lens
                    ctx.beginPath();
                    ctx.roundRect(headCenterX + 2, py + 3, 8, 6, 2);
                    ctx.fill();
                    // Bridge
                    ctx.fillRect(headCenterX - 2, py + 5, 4, 2);
                    // Shine
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(headCenterX - 8, py + 4, 3, 2);
                    ctx.fillRect(headCenterX + 4, py + 4, 3, 2);
                    break;

                case 'tophat':
                    // Top hat
                    ctx.fillStyle = '#1a1a1a';
                    // Brim
                    ctx.beginPath();
                    ctx.ellipse(headCenterX, headTopY + 2, 12, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tall crown
                    ctx.fillRect(headCenterX - 7, headTopY - 14, 14, 16);
                    // Band
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(headCenterX - 7, headTopY - 2, 14, 3);
                    break;

                case 'baseball':
                    // Baseball cap
                    ctx.fillStyle = '#2563eb';
                    // Cap dome
                    ctx.beginPath();
                    ctx.arc(headCenterX, headTopY + 2, 10, Math.PI, 0, false);
                    ctx.fill();
                    // Bill
                    const billDir = facingRight ? 1 : -1;
                    ctx.beginPath();
                    ctx.moveTo(headCenterX + (billDir * 2), headTopY + 2);
                    ctx.lineTo(headCenterX + (billDir * 14), headTopY + 5);
                    ctx.lineTo(headCenterX + (billDir * 12), headTopY + 8);
                    ctx.lineTo(headCenterX + (billDir * 2), headTopY + 4);
                    ctx.closePath();
                    ctx.fill();
                    // Button on top
                    ctx.fillStyle = '#1e40af';
                    ctx.beginPath();
                    ctx.arc(headCenterX, headTopY - 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'beanie':
                    // Beanie
                    ctx.fillStyle = '#dc2626';
                    // Main beanie
                    ctx.beginPath();
                    ctx.arc(headCenterX, headTopY + 2, 11, Math.PI, 0, false);
                    ctx.fill();
                    ctx.fillRect(headCenterX - 11, headTopY, 22, 4);
                    // Fold line
                    ctx.fillStyle = '#b91c1c';
                    ctx.fillRect(headCenterX - 10, headTopY + 1, 20, 3);
                    // Pom pom
                    ctx.fillStyle = '#fafafa';
                    ctx.beginPath();
                    ctx.arc(headCenterX, headTopY - 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'party':
                    // Party hat
                    ctx.fillStyle = '#ec4899';
                    // Cone
                    ctx.beginPath();
                    ctx.moveTo(headCenterX - 10, headTopY + 4);
                    ctx.lineTo(headCenterX, headTopY - 16);
                    ctx.lineTo(headCenterX + 10, headTopY + 4);
                    ctx.closePath();
                    ctx.fill();
                    // Stripes
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.moveTo(headCenterX - 6, headTopY - 2);
                    ctx.lineTo(headCenterX - 2, headTopY - 10);
                    ctx.lineTo(headCenterX + 2, headTopY - 10);
                    ctx.lineTo(headCenterX + 6, headTopY - 2);
                    ctx.closePath();
                    ctx.fill();
                    // Pom pom
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(headCenterX, headTopY - 16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }

        function drawCharacterPreview() {
            const canvas = document.getElementById('previewCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const custom = editingPlayer === 1 ? characterCustomization : player2Customization;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const px = 35;
            const py = 30;
            const pw = 28;
            const ph = 36;

            // Body
            ctx.fillStyle = custom.bodyColor;
            ctx.beginPath();
            ctx.roundRect(px + 4, py + 10, pw - 8, ph - 14, 5);
            ctx.fill();

            // Head
            ctx.fillStyle = custom.skinColor;
            ctx.beginPath();
            ctx.arc(px + pw / 2, py + 8, 10, 0, Math.PI * 2);
            ctx.fill();

            // Eye white (skip if sunglasses)
            if (custom.accessory !== 'sunglasses') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(px + pw / 2 + 3, py + 6, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eye pupil
                ctx.fillStyle = custom.eyeColor;
                ctx.beginPath();
                ctx.arc(px + pw / 2 + 4, py + 6, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player number indicator
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(editingPlayer === 1 ? '1' : '2', px + pw / 2, py + 24);

            // Legs
            ctx.fillStyle = darkenColor(custom.bodyColor, 0.15);
            ctx.fillRect(px + 6, py + ph - 8, 6, 8);
            ctx.fillRect(px + pw - 12, py + ph - 8, 6, 8);

            // Draw accessory
            drawAccessory(ctx, px, py, pw, custom.accessory, true);
        }

        function formatTime(ms) {
            const minutes = Math.floor(ms / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            const milliseconds = ms % 1000;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        function startSpeedrun() {
            speedrunStartTime = Date.now();
            speedrunRunning = true;
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
        }

        function stopSpeedrun() {
            speedrunRunning = false;
            speedrunTime = Date.now() - speedrunStartTime;
        }

        function resetSpeedrun() {
            speedrunRunning = false;
            speedrunTime = 0;
            speedrunStartTime = 0;
            document.getElementById('timerDisplay').textContent = '00:00.000';
        }

        function updateTimerDisplay() {
            if (speedrunRunning) {
                speedrunTime = Date.now() - speedrunStartTime;
                document.getElementById('timerDisplay').textContent = formatTime(speedrunTime);
                requestAnimationFrame(updateTimerDisplay);
            }
        }

        async function fetchLeaderboard() {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 5000);
                const res = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
                    headers: { 'X-Master-Key': JSONBIN_API_KEY },
                    signal: controller.signal
                });
                clearTimeout(timeout);
                if (!res.ok) throw new Error('fetch failed');
                const data = await res.json();
                leaderboardData = (data.record || []).filter(e => e.name && typeof e.time === 'number');
                localStorage.setItem('jumpGameLeaderboard', JSON.stringify(leaderboardData));
            } catch (e) {
                console.warn('Leaderboard fetch failed, using local data:', e);
                leaderboardData = JSON.parse(localStorage.getItem('jumpGameLeaderboard') || '[]');
            }
            return leaderboardData;
        }

        async function saveToLeaderboard(name, time) {
            await fetchLeaderboard();
            leaderboardData.push({ name, time, date: Date.now() });
            leaderboardData.sort((a, b) => a.time - b.time);
            leaderboardData = leaderboardData.slice(0, 10);
            localStorage.setItem('jumpGameLeaderboard', JSON.stringify(leaderboardData));
            try {
                await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': JSONBIN_API_KEY
                    },
                    body: JSON.stringify(leaderboardData)
                });
            } catch (e) {
                console.warn('Leaderboard save failed:', e);
            }
        }

        async function renderLeaderboard() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '<div class="no-entries">Loading...</div>';
            await fetchLeaderboard();
            if (leaderboardData.length === 0) {
                list.innerHTML = '<div class="no-entries">No times recorded yet. Complete all 10 levels!</div>';
                return;
            }
            list.innerHTML = leaderboardData.map((entry, i) => {
                let rankClass = '';
                if (i === 0) rankClass = 'gold';
                else if (i === 1) rankClass = 'silver';
                else if (i === 2) rankClass = 'bronze';
                const safeName = entry.name.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return `<div class="leaderboard-entry ${rankClass}">
                    <span class="rank">#${i + 1}</span>
                    <span class="name">${safeName}</span>
                    <span class="time">${formatTime(entry.time)}</span>
                </div>`;
            }).join('');
        }

        function showNameEntry() {
            document.getElementById('finalTime').textContent = formatTime(speedrunTime);
            document.getElementById('nameEntry').style.display = 'flex';
            document.getElementById('playerName').value = '';
            document.getElementById('playerName').focus();
        }

        // Game state
        let currentLevel = 0;
        let gameTime = 0;
        let particles = [];
        let shaderTime = 0;
        let gameState = 'menu'; // 'menu', 'playing', 'editor', 'testing'
        let editorTool = 'platform';
        let isDrawing = false;
        let drawStart = null;

        // Custom level for editor
        let customLevel = {
            playerStart: { x: 64, y: 500 },
            platforms: [],
            stickyPlatforms: [],
            bouncyPlatforms: [],
            spikes: [],
            lava: [],
            enemies: [],
            flag: null,
            movingPlatforms: []
        };

        // Saved custom levels
        let savedLevels = JSON.parse(localStorage.getItem('jumpGameLevels') || '[]');
        let currentEditingIndex = -1; // -1 means new level
        let canEdit = false; // Must click New Level or Edit to enable building

        // Player
        let twoPlayerMode = false;
        let chainedMode = false;
        const CHAIN_LENGTH = 100; // Maximum distance between chained players

        const player = {
            x: 64,
            y: 500,
            width: 28,
            height: 36,
            vx: 0,
            vy: 0,
            speed: 0.8,
            jumpForce: -13,
            wallJumpForce: 10,
            onGround: false,
            onWall: 0,
            onSticky: false,
            canWallJump: false,
            wallJumpCooldown: 0,
            facing: 1,
            animFrame: 0,
            animTimer: 0,
            dead: false,
            deathTimer: 0,
            isPlayer2: false
        };

        const player2 = {
            x: 96,
            y: 500,
            width: 28,
            height: 36,
            vx: 0,
            vy: 0,
            speed: 0.8,
            jumpForce: -13,
            wallJumpForce: 10,
            onGround: false,
            onWall: 0,
            onSticky: false,
            canWallJump: false,
            wallJumpCooldown: 0,
            facing: 1,
            animFrame: 0,
            animTimer: 0,
            dead: false,
            deathTimer: 0,
            isPlayer2: true
        };

        // Input
        const keys = {};
        document.addEventListener('keydown', e => {
            // Don't capture keys when typing in an input field
            const isTyping = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA';
            if (!isTyping) {
                keys[e.code] = true;
                if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                    e.preventDefault();
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        // Shader-like color functions
        function shaderColor(baseColor, x, y, time, type) {
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);

            let mod = 1;
            switch(type) {
                case 'player':
                    mod = 0.9 + 0.1 * Math.sin(time * 3 + y * 0.1);
                    break;
                case 'platform':
                    mod = 0.95 + 0.05 * Math.sin(time * 0.5 + x * 0.02 + y * 0.02);
                    break;
                case 'spike':
                    mod = 0.8 + 0.2 * Math.sin(time * 5 + x * 0.1);
                    break;
                case 'lava':
                    mod = 0.7 + 0.3 * Math.sin(time * 4 + x * 0.05);
                    break;
                case 'flag':
                    mod = 0.85 + 0.15 * Math.sin(time * 2 + y * 0.05);
                    break;
                case 'enemy':
                    mod = 0.85 + 0.15 * Math.sin(time * 6 + x * 0.1);
                    break;
            }

            return `rgb(${Math.floor(r * mod)}, ${Math.floor(g * mod)}, ${Math.floor(b * mod)})`;
        }

        function createGradient(x, y, w, h, color1, color2, time, type) {
            const gradient = ctx.createLinearGradient(x, y, x, y + h);
            gradient.addColorStop(0, shaderColor(color1, x, y, time, type));
            gradient.addColorStop(1, shaderColor(color2, x, y + h, time, type));
            return gradient;
        }

        // Particle system
        function spawnParticles(x, y, color, count, speed = 3) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * speed * 2,
                    vy: (Math.random() - 0.5) * speed * 2 - 2,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1;
                p.life -= p.decay;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Level data: 0=empty, 1=platform, 2=spike, 3=lava, 4=flag, 5=enemy spawn, 6=moving platform
        const defaultLevels = [
            // Level 1 - Introduction
            {
                playerStart: { x: 0, y: 576 },
                platforms: [
                    { x: 0, y: 608, w: 960, h: 32 },
                    { x: 96, y: 544, w: 192, h: 32 },
                    { x: 320, y: 512, w: 160, h: 32 },
                    { x: 512, y: 480, w: 128, h: 32 },
                    { x: 672, y: 448, w: 128, h: 32 },
                    { x: 832, y: 416, w: 128, h: 32 },
                ],
                spikes: [],
                lava: [],
                enemies: [],
                flag: { x: 928, y: 352 },
                movingPlatforms: []
            },
            // Level 2 - First Spikes
            {
                playerStart: { x: 0, y: 544 },
                platforms: [
                    { x: 0, y: 608, w: 960, h: 32 },
                    { x: 224, y: 544, w: 128, h: 32 },
                    { x: 384, y: 512, w: 128, h: 32 },
                    { x: 544, y: 480, w: 128, h: 32 },
                    { x: 704, y: 448, w: 128, h: 32 },
                ],
                spikes: [
                    { x: 96, y: 576, w: 32, h: 24 },
                    { x: 128, y: 576, w: 32, h: 24 },
                    { x: 160, y: 576, w: 32, h: 24 },
                    { x: 320, y: 512, w: 32, h: 24 },
                    { x: 480, y: 480, w: 32, h: 24 },
                    { x: 640, y: 448, w: 32, h: 24 },
                ],
                lava: [],
                enemies: [],
                flag: { x: 800, y: 384 },
                movingPlatforms: []
            },
            // Level 3 - Wall Jump Introduction
            {
                playerStart: { x: 64, y: 500 },
                platforms: [
                    { x: 0, y: 608, w: 300, h: 32 },
                    { x: 400, y: 150, w: 20, h: 490 },
                    { x: 500, y: 150, w: 20, h: 490 },
                    { x: 400, y: 130, w: 120, h: 20 },
                    { x: 600, y: 200, w: 100, h: 20 },
                    { x: 780, y: 200, w: 180, h: 20 },
                ],
                spikes: [],
                lava: [],
                enemies: [],
                flag: { x: 880, y: 152 },
                movingPlatforms: []
            },
            // Level 4 - Custom Level
            {
                playerStart: { x: 0, y: 576 },
                platforms: [
                    { x: 0, y: 608, w: 960, h: 32 },
                    { x: 128, y: 384, w: 32, h: 224 },
                    { x: 0, y: 128, w: 32, h: 320 },
                    { x: 96, y: 192, w: 128, h: 32 },
                    { x: 288, y: 352, w: 128, h: 32 },
                    { x: 512, y: 416, w: 128, h: 32 },
                    { x: 768, y: 384, w: 32, h: 32 },
                ],
                spikes: [
                    { x: 128, y: 352, w: 32, h: 24 },
                    { x: 0, y: 96, w: 32, h: 24 },
                ],
                lava: [],
                enemies: [
                    { x: 320, y: 320, patrol: 50 },
                    { x: 576, y: 384, patrol: 50 },
                    { x: 128, y: 160, patrol: 50 },
                ],
                flag: { x: 768, y: 352 },
                movingPlatforms: []
            },
            // Level 5 - Bouncy Ascent
            {
                playerStart: { x: 64, y: 500 },
                platforms: [
                    { x: 0, y: 576, w: 160, h: 32 },
                    { x: 480, y: 32, w: 96, h: 32 },
                ],
                stickyPlatforms: [],
                bouncyPlatforms: [
                    { x: 192, y: 512, w: 192, h: 32 },
                    { x: 192, y: 288, w: 192, h: 32 },
                    { x: 416, y: 384, w: 224, h: 32 },
                    { x: 416, y: 160, w: 224, h: 32 },
                ],
                spikes: [],
                lava: [
                    { x: 0, y: 608, w: 960, h: 32 },
                ],
                enemies: [],
                flag: { x: 512, y: 0 },
                movingPlatforms: []
            },
            // Level 6 - Moving Platforms
            {
                playerStart: { x: 64, y: 500 },
                platforms: [
                    { x: 0, y: 608, w: 160, h: 32 },
                    { x: 928, y: 224, w: 32, h: 32 },
                    { x: 192, y: 512, w: 32, h: 32 },
                ],
                stickyPlatforms: [],
                bouncyPlatforms: [
                    { x: 928, y: 544, w: 32, h: 32 },
                    { x: 800, y: 544, w: 160, h: 32 },
                ],
                spikes: [],
                lava: [
                    { x: 160, y: 608, w: 800, h: 32 },
                ],
                enemies: [],
                flag: { x: 928, y: 192 },
                movingPlatforms: [
                    { x: 448, y: 384, w: 64, h: 20, range: 100, speed: 3, vertical: true },
                    { x: 640, y: 288, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                    { x: 320, y: 480, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                ]
            },
            // Level 7 - Custom Level
            {
                playerStart: { x: 0, y: 576 },
                platforms: [
                    { x: 0, y: 608, w: 960, h: 32 },
                    { x: 928, y: 352, w: 32, h: 32 },
                    { x: 896, y: 352, w: 32, h: 32 },
                    { x: 864, y: 352, w: 32, h: 32 },
                    { x: 832, y: 352, w: 32, h: 32 },
                    { x: 800, y: 352, w: 32, h: 32 },
                    { x: 192, y: 256, w: 32, h: 352 },
                    { x: 384, y: 0, w: 32, h: 480 },
                    { x: 544, y: 96, w: 32, h: 512 },
                ],
                spikes: [],
                lava: [],
                enemies: [
                    { x: 800, y: 320, patrol: 50 },
                ],
                flag: { x: 928, y: 320 },
                movingPlatforms: []
            },
            // Level 8 - Bounce and Stick
            {
                playerStart: { x: 64, y: 500 },
                platforms: [
                    { x: 0, y: 608, w: 960, h: 32 },
                    { x: 768, y: 224, w: 192, h: 32 },
                ],
                stickyPlatforms: [
                    { x: 192, y: 480, w: 32, h: 32 },
                    { x: 192, y: 512, w: 32, h: 96 },
                    { x: 192, y: 480, w: 32, h: 128 },
                    { x: 448, y: 384, w: 32, h: 224 },
                    { x: 448, y: 320, w: 32, h: 288 },
                ],
                bouncyPlatforms: [
                    { x: 256, y: 576, w: 128, h: 32 },
                    { x: 576, y: 448, w: 32, h: 32 },
                    { x: 640, y: 448, w: 32, h: 32 },
                    { x: 608, y: 448, w: 32, h: 32 },
                    { x: 576, y: 448, w: 160, h: 32 },
                    { x: 736, y: 224, w: 32, h: 192 },
                ],
                spikes: [],
                lava: [
                    { x: 224, y: 576, w: 32, h: 32 },
                    { x: 416, y: 576, w: 32, h: 32 },
                    { x: 384, y: 576, w: 32, h: 32 },
                    { x: 480, y: 576, w: 480, h: 32 },
                ],
                enemies: [],
                flag: { x: 928, y: 192 },
                movingPlatforms: []
            },
            // Level 9 - Bounce to the Top
            {
                playerStart: { x: 64, y: 500 },
                platforms: [
                    { x: 0, y: 608, w: 192, h: 32 },
                    { x: 608, y: 320, w: 32, h: 32 },
                    { x: 544, y: 224, w: 32, h: 32 },
                    { x: 608, y: 128, w: 32, h: 32 },
                    { x: 608, y: 96, w: 32, h: 32 },
                    { x: 320, y: 64, w: 320, h: 32 },
                    { x: 288, y: 64, w: 32, h: 32 },
                    { x: 256, y: 64, w: 32, h: 32 },
                    { x: 224, y: 64, w: 32, h: 32 },
                    { x: 192, y: 64, w: 32, h: 32 },
                    { x: 160, y: 64, w: 32, h: 32 },
                    { x: 128, y: 64, w: 32, h: 32 },
                    { x: 96, y: 64, w: 32, h: 32 },
                    { x: 64, y: 64, w: 32, h: 32 },
                    { x: 32, y: 64, w: 32, h: 32 },
                    { x: 672, y: 128, w: 224, h: 32 },
                    { x: 736, y: 224, w: 224, h: 32 },
                    { x: 672, y: 320, w: 224, h: 32 },
                    { x: 736, y: 448, w: 224, h: 32 },
                    { x: 928, y: 608, w: 32, h: 32 },
                    { x: 896, y: 608, w: 32, h: 32 },
                    { x: 768, y: 544, w: 32, h: 32 },
                ],
                stickyPlatforms: [
                    { x: 640, y: 224, w: 32, h: 416 },
                ],
                bouncyPlatforms: [
                    { x: 128, y: 224, w: 32, h: 32 },
                    { x: 128, y: 224, w: 160, h: 32 },
                    { x: 0, y: 224, w: 288, h: 32 },
                ],
                spikes: [
                    { x: 640, y: 192, w: 32, h: 24 },
                ],
                lava: [
                    { x: 192, y: 608, w: 448, h: 32 },
                    { x: 672, y: 608, w: 224, h: 32 },
                ],
                enemies: [],
                flag: { x: 928, y: 544 },
                movingPlatforms: [
                    { x: 224, y: 512, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                    { x: 448, y: 416, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                    { x: 384, y: 160, w: 64, h: 20, range: 100, speed: 2, vertical: false },
                    { x: 768, y: 544, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                ]
            },
            // Level 10 - The Final Challenge
            {
                playerStart: { x: 64, y: 256 },
                platforms: [
                    { x: 0, y: 320, w: 128, h: 32 },
                    { x: 0, y: 160, w: 192, h: 32 },
                    { x: 192, y: 192, w: 32, h: 160 },
                    { x: 192, y: 160, w: 32, h: 32 },
                    { x: 704, y: 288, w: 32, h: 32 },
                    { x: 352, y: 320, w: 384, h: 32 },
                    { x: 448, y: 448, w: 32, h: 32 },
                    { x: 672, y: 416, w: 32, h: 192 },
                    { x: 544, y: 416, w: 128, h: 32 },
                    { x: 576, y: 160, w: 32, h: 32 },
                    { x: 640, y: 160, w: 32, h: 32 },
                ],
                stickyPlatforms: [
                    { x: 192, y: 288, w: 32, h: 32 },
                    { x: 192, y: 192, w: 32, h: 32 },
                    { x: 320, y: 192, w: 32, h: 160 },
                    { x: 704, y: 64, w: 32, h: 256 },
                    { x: 352, y: 320, w: 32, h: 32 },
                ],
                bouncyPlatforms: [
                    { x: 96, y: 512, w: 128, h: 32 },
                    { x: 576, y: 288, w: 128, h: 32 },
                    { x: 736, y: 288, w: 128, h: 32 },
                    { x: 864, y: 160, w: 96, h: 32 },
                    { x: 864, y: 416, w: 96, h: 32 },
                    { x: 704, y: 544, w: 160, h: 32 },
                ],
                spikes: [
                    { x: 640, y: 128, w: 32, h: 24 },
                    { x: 576, y: 128, w: 32, h: 24 },
                ],
                lava: [
                    { x: 0, y: 608, w: 960, h: 32 },
                ],
                enemies: [
                    { x: 64, y: 128, patrol: 50 },
                    { x: 160, y: 128, patrol: 50 },
                ],
                flag: { x: 608, y: 480 },
                movingPlatforms: [
                    { x: 384, y: 160, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                    { x: 512, y: 544, w: 64, h: 20, range: 80, speed: 2, vertical: false },
                ]
            }
        ];

        const levels = defaultLevels;

        let level = null;
        let enemies = [];

        function loadLevel(index) {
            level = levels[index];
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.vx = 0;
            player.vy = 0;
            player.dead = false;
            player.deathTimer = 0;
            particles = [];

            // Initialize player2 for 2 player mode or chained mode
            if (twoPlayerMode || chainedMode) {
                player2.x = level.playerStart.x + 32;
                player2.y = level.playerStart.y;
                player2.vx = 0;
                player2.vy = 0;
                player2.dead = false;
                player2.deathTimer = 0;
            }

            // Initialize enemies
            enemies = level.enemies.map(e => ({
                x: e.x,
                y: e.y,
                startX: e.x,
                patrol: e.patrol,
                width: 30,
                height: 30,
                vx: 1.5,
                direction: 1
            }));

            // Initialize moving platforms
            level.movingPlatforms.forEach(mp => {
                mp.startX = mp.x;
                mp.startY = mp.y;
                mp.offset = 0;
                mp.dir = 1;
            });

            levelDisplay.textContent = `Level ${index + 1}`;
        }

        function resetPlayer() {
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.vx = 0;
            player.vy = 0;
            player.dead = false;
            player.deathTimer = 0;

            // Reset player2 in 2 player mode or chained mode
            if (twoPlayerMode || chainedMode) {
                player2.x = level.playerStart.x + 32;
                player2.y = level.playerStart.y;
                player2.vx = 0;
                player2.vy = 0;
                player2.dead = false;
                player2.deathTimer = 0;
            }

            // Respawn all enemies
            enemies = level.enemies.map(e => ({
                x: e.x,
                y: e.y,
                startX: e.x,
                patrol: e.patrol,
                width: 30,
                height: 30,
                vx: 1.5,
                direction: 1
            }));
        }

        function showMessage(title, text, btnText, callback) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageBtn.textContent = btnText;
            message.style.display = 'block';
            messageBtn.onclick = () => {
                message.style.display = 'none';
                callback();
            };
        }

        function rectCollision(a, b) {
            return a.x < b.x + b.w &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.h &&
                   a.y + a.height > b.y;
        }

        function getAllPlatforms() {
            return [...level.platforms, ...level.movingPlatforms];
        }

        function getAllStickyPlatforms() {
            return level.stickyPlatforms || [];
        }

        function collideWithPlatforms(axis, plr = player) {
            const platforms = getAllPlatforms();
            const stickyPlatforms = getAllStickyPlatforms();
            plr.onGround = false;
            plr.onWall = 0;
            plr.onSticky = false;

            // Combine all solid platforms and sort by position to check closest first
            const allSolids = [
                ...platforms.map(p => ({ ...p, type: 'normal' })),
                ...stickyPlatforms.map(p => ({ ...p, type: 'sticky' }))
            ];

            // Sort by Y position (higher platforms first) for vertical checks
            // Sort by X position for horizontal checks
            if (axis === 'y') {
                allSolids.sort((a, b) => a.y - b.y);
            }

            for (const p of allSolids) {
                if (plr.x < p.x + p.w &&
                    plr.x + plr.width > p.x &&
                    plr.y < p.y + p.h &&
                    plr.y + plr.height > p.y) {

                    if (p.type === 'sticky') {
                        plr.onSticky = true;
                    }

                    if (axis === 'x') {
                        // Horizontal collision
                        if (plr.vx > 0) {
                            plr.x = p.x - plr.width;
                            plr.onWall = 1;
                        } else if (plr.vx < 0) {
                            plr.x = p.x + p.w;
                            plr.onWall = -1;
                        }
                        plr.vx = 0;
                    } else if (axis === 'y') {
                        // Vertical collision
                        if (plr.vy > 0) {
                            plr.y = p.y - plr.height;
                            plr.onGround = true;
                        } else if (plr.vy < 0) {
                            plr.y = p.y + p.h;
                        }
                        plr.vy = 0;
                    }
                }
            }

            // Check bouncy platforms (bounce based on velocity)
            const bouncyPlatforms = level.bouncyPlatforms || [];
            for (const p of bouncyPlatforms) {
                if (plr.x < p.x + p.w &&
                    plr.x + plr.width > p.x &&
                    plr.y < p.y + p.h &&
                    plr.y + plr.height > p.y) {

                    if (axis === 'x') {
                        // Horizontal bounce - bounce harder based on speed
                        const bounceForce = Math.max(8, Math.abs(plr.vx) * 1.5);
                        if (plr.vx > 0) {
                            plr.x = p.x - plr.width;
                            plr.vx = -bounceForce;
                        } else if (plr.vx < 0) {
                            plr.x = p.x + p.w;
                            plr.vx = bounceForce;
                        }
                        spawnParticles(plr.x + plr.width / 2, plr.y + plr.height / 2, '#22c55e', 6);
                    } else if (axis === 'y') {
                        // Vertical bounce - bounce harder based on fall speed
                        const minBounce = 10;
                        const bounceMultiplier = 1.3;
                        if (plr.vy > 0) {
                            // Landing on top - bounce up
                            plr.y = p.y - plr.height;
                            const bounceForce = Math.max(minBounce, Math.abs(plr.vy) * bounceMultiplier);
                            plr.vy = -bounceForce;
                            spawnParticles(plr.x + plr.width / 2, plr.y + plr.height, '#22c55e', 8);
                        } else if (plr.vy < 0) {
                            // Hitting from below - bounce down
                            plr.y = p.y + p.h;
                            const bounceForce = Math.max(minBounce / 2, Math.abs(plr.vy) * bounceMultiplier);
                            plr.vy = bounceForce;
                            spawnParticles(plr.x + plr.width / 2, plr.y, '#22c55e', 6);
                        }
                    }
                }
            }

            // Final check: if touching any sticky platform (with small margin), disable jumping
            const margin = 2;
            for (const p of stickyPlatforms) {
                if (plr.x < p.x + p.w + margin &&
                    plr.x + plr.width > p.x - margin &&
                    plr.y < p.y + p.h + margin &&
                    plr.y + plr.height > p.y - margin) {
                    plr.onSticky = true;
                    break;
                }
            }
        }

        // Chain constraint function - keeps players within chain length
        function applyChainConstraint() {
            if (!chainedMode || player.dead || player2.dead) return;

            const p1x = player.x + player.width / 2;
            const p1y = player.y + player.height / 2;
            const p2x = player2.x + player2.width / 2;
            const p2y = player2.y + player2.height / 2;

            const dx = p2x - p1x;
            const dy = p2y - p1y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > CHAIN_LENGTH) {
                // Calculate how much to pull each player
                const excess = distance - CHAIN_LENGTH;
                const nx = dx / distance; // normalized direction
                const ny = dy / distance;

                // Move both players toward each other (50% each)
                const pullAmount = excess / 2;

                player.x += nx * pullAmount;
                player.y += ny * pullAmount;
                player2.x -= nx * pullAmount;
                player2.y -= ny * pullAmount;

                // Also affect their velocities to make it feel more natural
                const velTransfer = 0.3;
                player.vx += nx * pullAmount * velTransfer;
                player.vy += ny * pullAmount * velTransfer;
                player2.vx -= nx * pullAmount * velTransfer;
                player2.vy -= ny * pullAmount * velTransfer;
            }
        }

        // Draw chain between players
        function drawChain() {
            if (!chainedMode || player.dead || player2.dead) return;

            const p1x = player.x + player.width / 2;
            const p1y = player.y + player.height / 2;
            const p2x = player2.x + player2.width / 2;
            const p2y = player2.y + player2.height / 2;

            const dx = p2x - p1x;
            const dy = p2y - p1y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Draw chain links
            const linkCount = Math.max(5, Math.floor(distance / 15));
            const linkSize = 6;

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(p1x, p1y);

            // Create a slight sag in the chain
            const midX = (p1x + p2x) / 2;
            const midY = (p1y + p2y) / 2 + Math.min(30, distance * 0.2);

            ctx.quadraticCurveTo(midX, midY, p2x, p2y);
            ctx.stroke();

            // Draw chain links along the curve
            ctx.fillStyle = '#888';
            for (let i = 0; i <= linkCount; i++) {
                const t = i / linkCount;
                // Quadratic bezier formula
                const x = (1-t)*(1-t)*p1x + 2*(1-t)*t*midX + t*t*p2x;
                const y = (1-t)*(1-t)*p1y + 2*(1-t)*t*midY + t*t*p2y;

                ctx.beginPath();
                ctx.arc(x, y, linkSize / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw tension indicator if chain is stretched
            if (distance > CHAIN_LENGTH * 0.8) {
                const tension = (distance - CHAIN_LENGTH * 0.8) / (CHAIN_LENGTH * 0.2);
                ctx.strokeStyle = `rgba(255, ${Math.floor(255 * (1 - tension))}, 0, ${Math.min(1, tension)})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p1x, p1y);
                ctx.quadraticCurveTo(midX, midY, p2x, p2y);
                ctx.stroke();
            }
        }

        // Helper function to update a single player with specified controls
        function updateSinglePlayer(plr, leftKey, rightKey, jumpKey) {
            if (plr.dead) return;

            // Player input
            let moveX = 0;
            if (keys[leftKey]) moveX = -1;
            if (keys[rightKey]) moveX = 1;

            plr.vx += moveX * plr.speed;
            plr.vx *= FRICTION;

            // Gravity
            plr.vy += GRAVITY;
            if (plr.vy > MAX_FALL_SPEED) plr.vy = MAX_FALL_SPEED;

            // Wall jump cooldown
            if (plr.wallJumpCooldown > 0) plr.wallJumpCooldown--;

            // Move horizontally
            plr.x += plr.vx;
            collideWithPlatforms('x', plr);

            // Move vertically
            plr.y += plr.vy;
            collideWithPlatforms('y', plr);

            // Check wall touch for wall sliding
            plr.onWall = 0;
            for (const p of getAllPlatforms()) {
                if (plr.y + plr.height > p.y && plr.y < p.y + p.h) {
                    if (plr.x + plr.width >= p.x - 2 && plr.x + plr.width <= p.x + 4) {
                        plr.onWall = 1;
                        break;
                    }
                    if (plr.x <= p.x + p.w + 2 && plr.x >= p.x + p.w - 4) {
                        plr.onWall = -1;
                        break;
                    }
                }
            }

            // Wall slide
            if (plr.onWall !== 0 && !plr.onGround && plr.vy > 0) {
                plr.vy = Math.min(plr.vy, 2);
                plr.canWallJump = true;
                if (gameTime % 5 === 0) {
                    spawnParticles(
                        plr.x + (plr.onWall > 0 ? plr.width : 0),
                        plr.y + plr.height / 2,
                        plr.isPlayer2 ? '#f472b6' : '#aaa', 1, 1
                    );
                }
            } else if (plr.onGround) {
                plr.canWallJump = false;
            }

            // Jump
            const jumpPressed = keys[jumpKey];
            if (jumpPressed && plr.onGround && !plr.onSticky) {
                plr.vy = plr.jumpForce;
                plr.onGround = false;
                spawnParticles(plr.x + plr.width / 2, plr.y + plr.height, plr.isPlayer2 ? '#f472b6' : '#fff', 8);
                playJumpSound();
            }
            // Wall jump
            if (jumpPressed && plr.canWallJump && plr.wallJumpCooldown === 0 && !plr.onSticky) {
                plr.vy = plr.jumpForce * 0.9;
                plr.vx = plr.wallJumpForce * -plr.onWall;
                plr.wallJumpCooldown = 15;
                plr.canWallJump = false;
                spawnParticles(
                    plr.x + (plr.onWall > 0 ? plr.width : 0),
                    plr.y + plr.height / 2,
                    plr.isPlayer2 ? '#f472b6' : '#7dd3fc', 10
                );
                playWallJumpSound();
            }

            // Update facing direction
            if (plr.vx > 0.5) plr.facing = 1;
            if (plr.vx < -0.5) plr.facing = -1;

            // Animation
            if (Math.abs(plr.vx) > 0.5 && plr.onGround) {
                plr.animFrame += 0.3;
            } else if (plr.onGround) {
                plr.animFrame = 0;
            }

            // Boundary check
            if (plr.x < 0) plr.x = 0;
            if (plr.x + plr.width > canvas.width) plr.x = canvas.width - plr.width;
            if (plr.y > canvas.height + 50) {
                killPlayerObj(plr);
            }

            // Check spike collision
            for (const spike of level.spikes) {
                const spikeRect = { x: spike.x, y: spike.y, w: spike.w, h: spike.h };
                if (rectCollision(plr, spikeRect)) {
                    killPlayerObj(plr);
                    break;
                }
            }

            // Check lava collision
            for (const lava of level.lava) {
                const lavaRect = { x: lava.x, y: lava.y, w: lava.w, h: lava.h };
                if (rectCollision(plr, lavaRect)) {
                    killPlayerObj(plr);
                    break;
                }
            }

            // Check enemy collision
            for (const enemy of enemies) {
                const enemyRect = { x: enemy.x, y: enemy.y, w: enemy.width, h: enemy.height };
                if (rectCollision(plr, enemyRect)) {
                    if (plr.vy > 0 && plr.y + plr.height - plr.vy < enemy.y + 10) {
                        plr.vy = plr.jumpForce * 0.7;
                        spawnParticles(enemy.x + enemy.width / 2, enemy.y, '#ff6b6b', 15);
                        enemies.splice(enemies.indexOf(enemy), 1);
                    } else {
                        killPlayerObj(plr);
                    }
                    break;
                }
            }
        }

        // Helper to carry player on moving platform
        function carryPlayerOnPlatform(plr, mp, prevX, prevY) {
            const wasOnPlatform = plr.x + plr.width > prevX &&
                                  plr.x < prevX + mp.w &&
                                  plr.y + plr.height >= prevY - 2 &&
                                  plr.y + plr.height <= prevY + 5;

            if (wasOnPlatform && plr.onGround) {
                if (mp.vertical) {
                    plr.y += (mp.y - prevY);
                } else {
                    plr.x += (mp.x - prevX);
                }
            }

            const nowOverlapping = plr.x + plr.width > mp.x &&
                                   plr.x < mp.x + mp.w &&
                                   plr.y + plr.height > mp.y &&
                                   plr.y < mp.y + mp.h;

            if (nowOverlapping && mp.vertical && mp.y < prevY) {
                plr.y = mp.y - plr.height;
                plr.vy = 0;
                plr.onGround = true;
            }
        }

        function killPlayerObj(plr) {
            if (!plr.dead) {
                plr.dead = true;
                plr.deathTimer = 0;
                spawnParticles(plr.x + plr.width / 2, plr.y + plr.height / 2, '#ff6b6b', 20, 5);
                spawnParticles(plr.x + plr.width / 2, plr.y + plr.height / 2, '#fff', 10, 3);
                playDeathSound();
            }
        }

        function update() {
            // Handle death and respawn
            if (player.dead) {
                player.deathTimer++;
            }
            if ((twoPlayerMode || chainedMode) && player2.dead) {
                player2.deathTimer++;
            }

            // In chained mode, if one dies, both die
            if (chainedMode) {
                if (player.dead && !player2.dead) {
                    killPlayerObj(player2);
                }
                if (player2.dead && !player.dead) {
                    killPlayerObj(player);
                }
            }

            // In single player, reset after death timer
            if (!twoPlayerMode && !chainedMode && player.dead && player.deathTimer > 60) {
                resetPlayer();
                updateParticles();
                return;
            }

            // In 2 player mode, respawn each player independently
            if (twoPlayerMode) {
                if (player.dead && player.deathTimer > 60) {
                    player.x = level.playerStart.x;
                    player.y = level.playerStart.y;
                    player.vx = 0;
                    player.vy = 0;
                    player.dead = false;
                    player.deathTimer = 0;
                }
                if (player2.dead && player2.deathTimer > 60) {
                    player2.x = level.playerStart.x + 32;
                    player2.y = level.playerStart.y;
                    player2.vx = 0;
                    player2.vy = 0;
                    player2.dead = false;
                    player2.deathTimer = 0;
                }
            }

            // In chained mode, reset when both are dead
            if (chainedMode && player.dead && player2.dead) {
                if (player.deathTimer > 60 || player2.deathTimer > 60) {
                    resetPlayer();
                }
                updateParticles();
                return;
            }

            // If only one player is dead in 2P mode, continue with the alive player
            if (!twoPlayerMode && !chainedMode && player.dead) {
                updateParticles();
                return;
            }

            gameTime++;
            shaderTime += 0.016;

            // Update moving platforms
            level.movingPlatforms.forEach(mp => {
                const prevX = mp.x;
                const prevY = mp.y;

                mp.offset += mp.speed * mp.dir;
                if (Math.abs(mp.offset) >= mp.range) {
                    mp.dir *= -1;
                }
                if (mp.vertical) {
                    mp.y = mp.startY + mp.offset;
                } else {
                    mp.x = mp.startX + mp.offset;
                }

                // Carry players on platforms
                if (!player.dead) carryPlayerOnPlatform(player, mp, prevX, prevY);
                if ((twoPlayerMode || chainedMode) && !player2.dead) carryPlayerOnPlatform(player2, mp, prevX, prevY);
            });

            // Update enemies
            enemies.forEach(enemy => {
                enemy.x += enemy.vx * enemy.direction;
                if (Math.abs(enemy.x - enemy.startX) > enemy.patrol) {
                    enemy.direction *= -1;
                }
            });

            // Update player 1 (Arrow keys in 2P/chained mode, both in 1P mode)
            if (!player.dead) {
                if (twoPlayerMode || chainedMode) {
                    updateSinglePlayer(player, 'ArrowLeft', 'ArrowRight', 'ArrowUp');
                } else {
                    // Single player uses both WASD and arrows
                    let moveX = 0;
                    if (keys['ArrowLeft'] || keys['KeyA']) moveX = -1;
                    if (keys['ArrowRight'] || keys['KeyD']) moveX = 1;
                    const jumpPressed = keys['ArrowUp'] || keys['KeyW'] || keys['Space'];

                    player.vx += moveX * player.speed;
                    player.vx *= FRICTION;
                    player.vy += GRAVITY;
                    if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;
                    if (player.wallJumpCooldown > 0) player.wallJumpCooldown--;

                    player.x += player.vx;
                    collideWithPlatforms('x', player);
                    player.y += player.vy;
                    collideWithPlatforms('y', player);

                    // Wall check
                    player.onWall = 0;
                    for (const p of getAllPlatforms()) {
                        if (player.y + player.height > p.y && player.y < p.y + p.h) {
                            if (player.x + player.width >= p.x - 2 && player.x + player.width <= p.x + 4) {
                                player.onWall = 1;
                                break;
                            }
                            if (player.x <= p.x + p.w + 2 && player.x >= p.x + p.w - 4) {
                                player.onWall = -1;
                                break;
                            }
                        }
                    }

                    if (player.onWall !== 0 && !player.onGround && player.vy > 0) {
                        player.vy = Math.min(player.vy, 2);
                        player.canWallJump = true;
                        if (gameTime % 5 === 0) {
                            spawnParticles(player.x + (player.onWall > 0 ? player.width : 0), player.y + player.height / 2, '#aaa', 1, 1);
                        }
                    } else if (player.onGround) {
                        player.canWallJump = false;
                    }

                    if (jumpPressed && player.onGround && !player.onSticky) {
                        player.vy = player.jumpForce;
                        player.onGround = false;
                        spawnParticles(player.x + player.width / 2, player.y + player.height, '#fff', 8);
                        playJumpSound();
                    }
                    if (jumpPressed && player.canWallJump && player.wallJumpCooldown === 0 && !player.onSticky) {
                        player.vy = player.jumpForce * 0.9;
                        player.vx = player.wallJumpForce * -player.onWall;
                        player.wallJumpCooldown = 15;
                        player.canWallJump = false;
                        spawnParticles(player.x + (player.onWall > 0 ? player.width : 0), player.y + player.height / 2, '#7dd3fc', 10);
                        playWallJumpSound();
                    }

                    if (player.vx > 0.5) player.facing = 1;
                    if (player.vx < -0.5) player.facing = -1;
                    if (Math.abs(player.vx) > 0.5 && player.onGround) {
                        player.animFrame += 0.3;
                    } else if (player.onGround) {
                        player.animFrame = 0;
                    }

                    if (player.x < 0) player.x = 0;
                    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                    if (player.y > canvas.height + 50) killPlayer();

                    for (const spike of level.spikes) {
                        if (rectCollision(player, { x: spike.x, y: spike.y, w: spike.w, h: spike.h })) {
                            killPlayer();
                            break;
                        }
                    }
                    for (const lava of level.lava) {
                        if (rectCollision(player, { x: lava.x, y: lava.y, w: lava.w, h: lava.h })) {
                            killPlayer();
                            break;
                        }
                    }
                    for (const enemy of enemies) {
                        const enemyRect = { x: enemy.x, y: enemy.y, w: enemy.width, h: enemy.height };
                        if (rectCollision(player, enemyRect)) {
                            if (player.vy > 0 && player.y + player.height - player.vy < enemy.y + 10) {
                                player.vy = player.jumpForce * 0.7;
                                spawnParticles(enemy.x + enemy.width / 2, enemy.y, '#ff6b6b', 15);
                                enemies.splice(enemies.indexOf(enemy), 1);
                            } else {
                                killPlayer();
                            }
                            break;
                        }
                    }
                }
            }

            // Update player 2 (WASD) in 2 player mode or chained mode
            if ((twoPlayerMode || chainedMode) && !player2.dead) {
                updateSinglePlayer(player2, 'KeyA', 'KeyD', 'KeyW');
            }

            // Apply chain constraint if in chained mode
            if (chainedMode) {
                applyChainConstraint();
            }

            // Check flag collision
            const flagRect = { x: level.flag.x, y: level.flag.y, w: 40, h: 48 };
            if (chainedMode) {
                // In chained mode, BOTH players must reach the flag
                const p1AtFlag = !player.dead && rectCollision(player, flagRect);
                const p2AtFlag = !player2.dead && rectCollision(player2, flagRect);
                if (p1AtFlag && p2AtFlag) {
                    levelComplete();
                }
            } else {
                if (!player.dead && rectCollision(player, flagRect)) {
                    levelComplete();
                }
                if (twoPlayerMode && !player2.dead && rectCollision(player2, flagRect)) {
                    levelComplete();
                }
            }

            updateParticles();
        }

        function killPlayer() {
            if (!player.dead) {
                player.dead = true;
                player.deathTimer = 0;
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, '#ff6b6b', 20, 5);
                spawnParticles(player.x + player.width / 2, player.y + player.height / 2, '#fff', 10, 3);
                playDeathSound();
            }
        }

        let levelCompleted = false;

        function levelComplete() {
            if (levelCompleted) return; // Prevent multiple triggers
            levelCompleted = true;

            spawnParticles(level.flag.x + 20, level.flag.y + 24, '#fcd34d', 30, 5);
            playLevelCompleteSound();

            if (currentLevel < levels.length - 1) {
                showMessage(
                    'Level Complete!',
                    `You completed level ${currentLevel + 1}!`,
                    'Next Level',
                    () => {
                        levelCompleted = false;
                        currentLevel++;
                        loadLevel(currentLevel);
                    }
                );
            } else {
                // Completed all levels - stop timer and show name entry
                stopSpeedrun();
                showNameEntry();
            }
        }

        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f0f23');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Animated stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73 + gameTime * 0.1) % canvas.width;
                const y = (i * 37) % (canvas.height * 0.6);
                const size = 1 + Math.sin(gameTime * 0.05 + i) * 0.5;
                ctx.globalAlpha = 0.3 + Math.sin(gameTime * 0.03 + i * 0.5) * 0.2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawPlatform(p) {
            const gradient = createGradient(p.x, p.y, p.w, p.h, '#4a5568', '#2d3748', shaderTime, 'platform');
            ctx.fillStyle = gradient;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Top highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(p.x, p.y, p.w, 3);

            // Edge shading
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(p.x, p.y + p.h - 2, p.w, 2);
        }

        function drawStickyPlatform(p) {
            const gradient = createGradient(p.x, p.y, p.w, p.h, '#eab308', '#ca8a04', shaderTime, 'platform');
            ctx.fillStyle = gradient;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Top highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(p.x, p.y, p.w, 3);

            // Sticky texture pattern
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            for (let i = 0; i < p.w; i += 12) {
                ctx.fillRect(p.x + i, p.y + 4, 6, p.h - 6);
            }

            // Edge shading
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(p.x, p.y + p.h - 2, p.w, 2);
        }

        function drawBouncyPlatform(p) {
            const gradient = createGradient(p.x, p.y, p.w, p.h, '#22c55e', '#16a34a', shaderTime, 'platform');
            ctx.fillStyle = gradient;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Bouncy spring pattern
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 8; i < p.w - 8; i += 16) {
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y + 4);
                ctx.lineTo(p.x + i + 4, p.y + p.h / 2);
                ctx.lineTo(p.x + i + 8, p.y + 4);
                ctx.stroke();
            }

            // Top highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(p.x, p.y, p.w, 3);

            // Edge shading
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(p.x, p.y + p.h - 2, p.w, 2);
        }

        function drawMovingPlatform(p) {
            const gradient = createGradient(p.x, p.y, p.w, p.h, '#6366f1', '#4338ca', shaderTime, 'platform');
            ctx.fillStyle = gradient;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Glow effect
            ctx.shadowColor = '#6366f1';
            ctx.shadowBlur = 10 + Math.sin(shaderTime * 3) * 5;
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.shadowBlur = 0;

            // Top highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(p.x, p.y, p.w, 2);
        }

        function drawSpike(s) {
            // Find the platform below the spike
            const platforms = level ? level.platforms : (customLevel ? customLevel.platforms : []);
            let groundY = s.y + s.h;
            for (const p of platforms) {
                if (s.x + s.w / 2 >= p.x && s.x + s.w / 2 <= p.x + p.w && p.y >= s.y + s.h) {
                    if (p.y < groundY || groundY === s.y + s.h) {
                        groundY = p.y;
                    }
                }
            }

            const spikes = Math.floor(s.w / 16);
            for (let i = 0; i < spikes; i++) {
                const x = s.x + i * 16 + 8;
                const color = shaderColor('#dc2626', x, s.y, shaderTime, 'spike');

                // Draw spike triangle extending to the ground
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x - 8, groundY);
                ctx.lineTo(x, s.y);
                ctx.lineTo(x + 8, groundY);
                ctx.closePath();
                ctx.fill();

                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x - 4, groundY);
                ctx.lineTo(x, s.y + 4);
                ctx.lineTo(x, groundY);
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawLava(l) {
            // Lava base
            const gradient = createGradient(l.x, l.y, l.w, l.h, '#f97316', '#dc2626', shaderTime, 'lava');
            ctx.fillStyle = gradient;
            ctx.fillRect(l.x, l.y, l.w, l.h);

            // Animated waves
            ctx.fillStyle = shaderColor('#fcd34d', l.x, l.y, shaderTime, 'lava');
            for (let x = l.x; x < l.x + l.w; x += 20) {
                const waveY = l.y + Math.sin(shaderTime * 3 + x * 0.1) * 3;
                ctx.beginPath();
                ctx.arc(x + 10, waveY + 5, 8, Math.PI, 0);
                ctx.fill();
            }

            // Glow
            ctx.shadowColor = '#f97316';
            ctx.shadowBlur = 20;
            ctx.fillStyle = 'rgba(249, 115, 22, 0.3)';
            ctx.fillRect(l.x, l.y - 10, l.w, 10);
            ctx.shadowBlur = 0;

            // Bubbles
            for (let i = 0; i < 5; i++) {
                const bx = l.x + ((i * 150 + gameTime) % l.w);
                const by = l.y + 10 + Math.sin(gameTime * 0.1 + i) * 5;
                ctx.fillStyle = 'rgba(255, 200, 100, 0.5)';
                ctx.beginPath();
                ctx.arc(bx, by, 3 + Math.sin(gameTime * 0.2 + i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFlag(f) {
            // Find the platform below the flag
            const platforms = level ? level.platforms : (customLevel ? customLevel.platforms : []);
            let groundY = 640; // Default to bottom of canvas
            for (const p of platforms) {
                if (f.x + 7 >= p.x && f.x + 7 <= p.x + p.w && p.y > f.y) {
                    if (p.y < groundY) {
                        groundY = p.y;
                    }
                }
            }

            // Pole - extends down to platform below
            const poleHeight = groundY - f.y;
            ctx.fillStyle = '#a0a0a0';
            ctx.fillRect(f.x + 5, f.y, 4, poleHeight);

            // Pole shadow
            ctx.fillStyle = '#808080';
            ctx.fillRect(f.x + 5, f.y, 2, poleHeight);

            // Flag cloth with wave animation
            const flagColor = shaderColor('#22c55e', f.x, f.y, shaderTime, 'flag');
            ctx.fillStyle = flagColor;
            ctx.beginPath();
            ctx.moveTo(f.x + 9, f.y);

            // Wavy top edge
            for (let i = 0; i <= 30; i += 5) {
                const waveY = f.y + Math.sin(shaderTime * 4 + i * 0.2) * 2;
                ctx.lineTo(f.x + 9 + i, waveY);
            }

            ctx.lineTo(f.x + 39, f.y + 15);

            // Wavy bottom edge
            for (let i = 30; i >= 0; i -= 5) {
                const waveY = f.y + 30 + Math.sin(shaderTime * 4 + i * 0.2) * 2;
                ctx.lineTo(f.x + 9 + i, waveY);
            }

            ctx.closePath();
            ctx.fill();

            // Star on flag
            ctx.fillStyle = '#fcd34d';
            const starX = f.x + 22;
            const starY = f.y + 15 + Math.sin(shaderTime * 4 + 15 * 0.2) * 2;
            drawStar(starX, starY, 5, 6, 3);

            // Pole top
            ctx.fillStyle = '#fcd34d';
            ctx.beginPath();
            ctx.arc(f.x + 7, f.y - 3, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        function drawEnemy(e) {
            const color = shaderColor('#ef4444', e.x, e.y, shaderTime, 'enemy');

            // Body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(e.x + e.width / 2, e.y + e.height / 2, e.width / 2, 0, Math.PI * 2);
            ctx.fill();

            // Angry eyes
            ctx.fillStyle = '#fff';
            const eyeOffset = e.direction > 0 ? 4 : -4;
            ctx.beginPath();
            ctx.arc(e.x + e.width / 2 - 6 + eyeOffset, e.y + e.height / 2 - 3, 5, 0, Math.PI * 2);
            ctx.arc(e.x + e.width / 2 + 6 + eyeOffset, e.y + e.height / 2 - 3, 5, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(e.x + e.width / 2 - 4 + eyeOffset, e.y + e.height / 2 - 3, 2, 0, Math.PI * 2);
            ctx.arc(e.x + e.width / 2 + 8 + eyeOffset, e.y + e.height / 2 - 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // Angry eyebrows
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(e.x + e.width / 2 - 10, e.y + e.height / 2 - 10);
            ctx.lineTo(e.x + e.width / 2 - 2, e.y + e.height / 2 - 6);
            ctx.moveTo(e.x + e.width / 2 + 10, e.y + e.height / 2 - 10);
            ctx.lineTo(e.x + e.width / 2 + 2, e.y + e.height / 2 - 6);
            ctx.stroke();

            // Spikes
            ctx.fillStyle = shaderColor('#b91c1c', e.x, e.y, shaderTime, 'enemy');
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + shaderTime;
                const sx = e.x + e.width / 2 + Math.cos(angle) * (e.width / 2);
                const sy = e.y + e.height / 2 + Math.sin(angle) * (e.height / 2);
                const ex = e.x + e.width / 2 + Math.cos(angle) * (e.width / 2 + 8);
                const ey = e.y + e.height / 2 + Math.sin(angle) * (e.height / 2 + 8);

                ctx.beginPath();
                ctx.moveTo(sx - 3, sy);
                ctx.lineTo(ex, ey);
                ctx.lineTo(sx + 3, sy);
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawPlayer() {
            if (player.dead) {
                // Death animation - just particles
                return;
            }

            const px = player.x;
            const py = player.y;
            const pw = player.width;
            const ph = player.height;

            ctx.save();

            // Flip for direction
            if (player.facing === -1) {
                ctx.translate(px + pw / 2, 0);
                ctx.scale(-1, 1);
                ctx.translate(-(px + pw / 2), 0);
            }

            // Body gradient shader effect
            const bodyLight = lightenColor(characterCustomization.bodyColor, 0.15);
            const bodyGradient = createGradient(px, py, pw, ph, bodyLight, characterCustomization.bodyColor, shaderTime, 'player');
            ctx.fillStyle = bodyGradient;

            // Body
            ctx.beginPath();
            ctx.roundRect(px + 4, py + 10, pw - 8, ph - 14, 5);
            ctx.fill();

            // Head
            const skinLight = lightenColor(characterCustomization.skinColor, 0.1);
            const headGradient = createGradient(px, py, pw, 20, skinLight, characterCustomization.skinColor, shaderTime, 'player');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(px + pw / 2, py + 8, 10, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (skip if sunglasses)
            if (characterCustomization.accessory !== 'sunglasses') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(px + pw / 2 + 3, py + 6, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = characterCustomization.eyeColor;
                ctx.beginPath();
                ctx.arc(px + pw / 2 + 4, py + 6, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw accessory
            if (characterCustomization.accessory !== 'none') {
                drawAccessory(ctx, px, py, pw, characterCustomization.accessory, true);
            }

            // "1" indicator in 2 player or chained mode
            if (twoPlayerMode || chainedMode) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('1', px + pw / 2, py + 24);
            }

            // Legs animation
            ctx.fillStyle = darkenColor(characterCustomization.bodyColor, 0.15);

            if (player.onGround) {
                // Walking animation when on ground
                const isMoving = Math.abs(player.vx) > 0.5;
                const legSwing = isMoving ? Math.sin(player.animFrame * 0.8) * 4 : 0;

                // Left leg
                ctx.save();
                ctx.translate(px + 9, py + ph - 8);
                ctx.rotate(legSwing * 0.15);
                ctx.fillRect(-3, 0, 6, 8);
                ctx.restore();

                // Right leg (opposite phase)
                ctx.save();
                ctx.translate(px + pw - 9, py + ph - 8);
                ctx.rotate(-legSwing * 0.15);
                ctx.fillRect(-3, 0, 6, 8);
                ctx.restore();
            } else if (player.canWallJump) {
                // Tucked legs when wall sliding
                ctx.fillRect(px + 8, py + ph - 6, 5, 5);
                ctx.fillRect(px + pw - 13, py + ph - 6, 5, 5);
            } else {
                // Spread legs when jumping/falling
                const jumpPhase = Math.min(1, Math.abs(player.vy) / 10);
                const spread = jumpPhase * 4;
                // Left leg angled
                ctx.save();
                ctx.translate(px + 9, py + ph - 8);
                ctx.rotate(-spread * 0.3);
                ctx.fillRect(-3, 0, 6, 7);
                ctx.restore();
                // Right leg angled
                ctx.save();
                ctx.translate(px + pw - 9, py + ph - 8);
                ctx.rotate(spread * 0.3);
                ctx.fillRect(-3, 0, 6, 7);
                ctx.restore();
            }

            // Arm when wall grabbing
            if (player.canWallJump) {
                ctx.fillStyle = characterCustomization.skinColor;
                const armDir = player.onWall; // 1 = right wall, -1 = left wall
                const armX = armDir > 0 ? px + pw - 2 : px - 4;
                const armY = py + 14;

                // Upper arm
                ctx.fillRect(armX, armY, 6, 4);
                // Hand grabbing
                ctx.beginPath();
                ctx.arc(armX + (armDir > 0 ? 5 : 1), armY + 2, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow effect when wall sliding
            if (player.canWallJump) {
                ctx.shadowColor = '#7dd3fc';
                ctx.shadowBlur = 15;
                ctx.fillStyle = 'rgba(125, 211, 252, 0.3)';
                ctx.fillRect(px, py, pw, ph);
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function drawPlayer2() {
            if ((!twoPlayerMode && !chainedMode) || player2.dead) return;

            const px = player2.x;
            const py = player2.y;
            const pw = player2.width;
            const ph = player2.height;

            // Player 2 colors from customization
            const p2 = player2Customization;

            ctx.save();

            if (player2.facing === -1) {
                ctx.translate(px + pw / 2, 0);
                ctx.scale(-1, 1);
                ctx.translate(-(px + pw / 2), 0);
            }

            // Body
            const bodyLight = lightenColor(p2.bodyColor, 0.15);
            const bodyGradient = createGradient(px, py, pw, ph, bodyLight, p2.bodyColor, shaderTime, 'player');
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.roundRect(px + 4, py + 10, pw - 8, ph - 14, 5);
            ctx.fill();

            // Head
            const skinLight = lightenColor(p2.skinColor, 0.1);
            const headGradient = createGradient(px, py, pw, 20, skinLight, p2.skinColor, shaderTime, 'player');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(px + pw / 2, py + 8, 10, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (skip if sunglasses)
            if (p2.accessory !== 'sunglasses') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(px + pw / 2 + 3, py + 6, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = p2.eyeColor;
                ctx.beginPath();
                ctx.arc(px + pw / 2 + 4, py + 6, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw accessory
            if (p2.accessory !== 'none') {
                drawAccessory(ctx, px, py, pw, p2.accessory, true);
            }

            // "2" indicator on body
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('2', px + pw / 2, py + 24);

            // Legs animation
            ctx.fillStyle = darkenColor(p2.bodyColor, 0.15);

            if (player2.onGround) {
                const isMoving = Math.abs(player2.vx) > 0.5;
                const legSwing = isMoving ? Math.sin(player2.animFrame * 0.8) * 4 : 0;
                ctx.save();
                ctx.translate(px + 9, py + ph - 8);
                ctx.rotate(legSwing * 0.15);
                ctx.fillRect(-3, 0, 6, 8);
                ctx.restore();
                ctx.save();
                ctx.translate(px + pw - 9, py + ph - 8);
                ctx.rotate(-legSwing * 0.15);
                ctx.fillRect(-3, 0, 6, 8);
                ctx.restore();
            } else if (player2.canWallJump) {
                ctx.fillRect(px + 8, py + ph - 6, 5, 5);
                ctx.fillRect(px + pw - 13, py + ph - 6, 5, 5);
            } else {
                const jumpPhase = Math.min(1, Math.abs(player2.vy) / 10);
                const spread = jumpPhase * 4;
                ctx.save();
                ctx.translate(px + 9, py + ph - 8);
                ctx.rotate(-spread * 0.3);
                ctx.fillRect(-3, 0, 6, 7);
                ctx.restore();
                ctx.save();
                ctx.translate(px + pw - 9, py + ph - 8);
                ctx.rotate(spread * 0.3);
                ctx.fillRect(-3, 0, 6, 7);
                ctx.restore();
            }

            // Arm when wall grabbing
            if (player2.canWallJump) {
                ctx.fillStyle = p2.skinColor;
                const armDir = player2.onWall;
                const armX = armDir > 0 ? px + pw - 2 : px - 4;
                const armY = py + 14;
                ctx.fillRect(armX, armY, 6, 4);
                ctx.beginPath();
                ctx.arc(armX + (armDir > 0 ? 5 : 1), armY + 2, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow effect when wall sliding
            if (player2.canWallJump) {
                ctx.shadowColor = lightenColor(p2.bodyColor, 0.3);
                ctx.shadowBlur = 15;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(px, py, pw, ph);
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        function draw() {
            drawBackground();

            // Draw platforms
            level.platforms.forEach(drawPlatform);
            level.movingPlatforms.forEach(drawMovingPlatform);
            (level.stickyPlatforms || []).forEach(drawStickyPlatform);
            (level.bouncyPlatforms || []).forEach(drawBouncyPlatform);

            // Draw hazards
            level.spikes.forEach(drawSpike);
            level.lava.forEach(drawLava);

            // Draw flag
            drawFlag(level.flag);

            // Draw enemies
            enemies.forEach(drawEnemy);

            // Draw particles
            drawParticles();

            // Draw chain (before players so it appears behind them)
            drawChain();

            // Draw player
            drawPlayer();
            drawPlayer2();
        }

        function gameLoop() {
            if (gameState === 'playing' || gameState === 'testing') {
                update();
                draw();
            } else if (gameState === 'editor') {
                drawEditor();
            }
            requestAnimationFrame(gameLoop);
        }

        // Editor functions
        function drawEditor() {
            drawBackground();

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw placed objects
            customLevel.platforms.forEach(drawPlatform);
            (customLevel.stickyPlatforms || []).forEach(drawStickyPlatform);
            (customLevel.bouncyPlatforms || []).forEach(drawBouncyPlatform);
            customLevel.spikes.forEach(drawSpike);
            customLevel.lava.forEach(drawLava);

            // Draw moving platforms
            (customLevel.movingPlatforms || []).forEach(mp => {
                const isSelected = mp === selectedMovingPlatform;

                // Draw the platform
                ctx.fillStyle = isSelected ? '#818cf8' : '#6366f1';
                ctx.fillRect(mp.x, mp.y, mp.w, mp.h);
                ctx.strokeStyle = isSelected ? '#fbbf24' : '#818cf8';
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.strokeRect(mp.x, mp.y, mp.w, mp.h);

                // Draw movement range indicator
                ctx.strokeStyle = isSelected ? 'rgba(251, 191, 36, 0.6)' : 'rgba(99, 102, 241, 0.5)';
                ctx.setLineDash([5, 5]);
                if (mp.vertical) {
                    ctx.strokeRect(mp.x, mp.y - mp.range, mp.w, mp.h + mp.range * 2);
                } else {
                    ctx.strokeRect(mp.x - mp.range, mp.y, mp.w + mp.range * 2, mp.h);
                }
                ctx.setLineDash([]);

                // Draw direction arrow
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(mp.vertical ? 'â†•' : 'â†”', mp.x + mp.w/2, mp.y + mp.h/2 + 4);
            });

            // Draw enemies
            customLevel.enemies.forEach(e => {
                drawEnemy({ x: e.x, y: e.y, width: 30, height: 30, direction: 1 });
            });

            // Draw flag
            if (customLevel.flag) {
                drawFlag(customLevel.flag);
            }

            // Draw spawn point
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.arc(customLevel.playerStart.x + 14, customLevel.playerStart.y + 18, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('P', customLevel.playerStart.x + 14, customLevel.playerStart.y + 22);

            // Draw current selection preview
            if (isDrawing && drawStart) {
                const mousePos = currentMousePos || drawStart;
                ctx.strokeStyle = '#7dd3fc';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const x = Math.min(drawStart.x, mousePos.x);
                const y = Math.min(drawStart.y, mousePos.y);
                const w = Math.abs(mousePos.x - drawStart.x);
                const h = Math.abs(mousePos.y - drawStart.y);
                ctx.strokeRect(x, y, w, h);
                ctx.setLineDash([]);
            }

            // Show message if editing not enabled
            if (!canEdit) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#7dd3fc';
                ctx.font = 'bold 24px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click "+ New" or "Edit" a level to start building', canvas.width / 2, canvas.height / 2);
            }
        }

        let currentMousePos = null;

        function snapToGrid(val) {
            return Math.floor(val / TILE_SIZE) * TILE_SIZE;
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'editor' || !canEdit) return;
            const pos = getMousePos(e);

            if (editorTool === 'spawn') {
                customLevel.playerStart = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };
            } else if (editorTool === 'flag') {
                customLevel.flag = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };
            } else if (editorTool === 'enemy') {
                customLevel.enemies.push({ x: snapToGrid(pos.x), y: snapToGrid(pos.y), patrol: 50 });
            } else if (editorTool === 'erase') {
                eraseAt(pos.x, pos.y);
            } else if (editorTool === 'moving') {
                // Check if clicking on existing moving platform to select it
                const mps = customLevel.movingPlatforms || [];
                let clickedMp = null;
                for (let mp of mps) {
                    if (pos.x >= mp.x && pos.x <= mp.x + mp.w && pos.y >= mp.y && pos.y <= mp.y + mp.h) {
                        clickedMp = mp;
                        break;
                    }
                }
                if (clickedMp) {
                    selectedMovingPlatform = clickedMp;
                    mpRangeInput.value = clickedMp.range;
                    mpSpeedInput.value = clickedMp.speed;
                    mpVerticalInput.checked = clickedMp.vertical;
                    selectedMpInfo.textContent = 'Selected - edit values above';
                } else {
                    selectedMovingPlatform = null;
                    selectedMpInfo.textContent = '';
                    isDrawing = true;
                    drawStart = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };
                }
            } else {
                isDrawing = true;
                drawStart = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'editor') return;
            currentMousePos = getMousePos(e);
            if (editorTool === 'erase' && e.buttons === 1) {
                eraseAt(currentMousePos.x, currentMousePos.y);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState !== 'editor' || !isDrawing) return;
            const pos = getMousePos(e);
            const endPos = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };

            const x = Math.min(drawStart.x, endPos.x);
            const y = Math.min(drawStart.y, endPos.y);
            const w = Math.max(TILE_SIZE, Math.abs(endPos.x - drawStart.x) + TILE_SIZE);
            const h = Math.max(TILE_SIZE, Math.abs(endPos.y - drawStart.y) + TILE_SIZE);

            if (editorTool === 'platform') {
                customLevel.platforms.push({ x, y, w, h });
            } else if (editorTool === 'sticky') {
                customLevel.stickyPlatforms = customLevel.stickyPlatforms || [];
                customLevel.stickyPlatforms.push({ x, y, w, h });
            } else if (editorTool === 'bouncy') {
                customLevel.bouncyPlatforms = customLevel.bouncyPlatforms || [];
                customLevel.bouncyPlatforms.push({ x, y, w, h });
            } else if (editorTool === 'moving') {
                // Use values from inputs
                const range = parseInt(mpRangeInput.value) || 80;
                const speed = parseFloat(mpSpeedInput.value) || 2;
                const vertical = mpVerticalInput.checked;
                customLevel.movingPlatforms = customLevel.movingPlatforms || [];
                customLevel.movingPlatforms.push({
                    x, y,
                    w: Math.max(64, w),
                    h: 20,
                    range: range,
                    speed: speed,
                    vertical: vertical
                });
                selectedMpInfo.textContent = 'Platform placed!';
            } else if (editorTool === 'spike') {
                customLevel.spikes.push({ x, y, w, h: 24 });
            } else if (editorTool === 'lava') {
                customLevel.lava.push({ x, y, w, h: Math.max(32, h) });
            }

            isDrawing = false;
            drawStart = null;
        });

        function eraseAt(x, y) {
            // Erase platforms
            customLevel.platforms = customLevel.platforms.filter(p =>
                !(x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h)
            );
            // Erase sticky platforms
            if (customLevel.stickyPlatforms) {
                customLevel.stickyPlatforms = customLevel.stickyPlatforms.filter(p =>
                    !(x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h)
                );
            }
            // Erase bouncy platforms
            if (customLevel.bouncyPlatforms) {
                customLevel.bouncyPlatforms = customLevel.bouncyPlatforms.filter(p =>
                    !(x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h)
                );
            }
            // Erase spikes
            customLevel.spikes = customLevel.spikes.filter(p =>
                !(x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h)
            );
            // Erase lava
            customLevel.lava = customLevel.lava.filter(p =>
                !(x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h)
            );
            // Erase enemies
            customLevel.enemies = customLevel.enemies.filter(e =>
                !(x >= e.x && x <= e.x + 30 && y >= e.y && y <= e.y + 30)
            );
            // Erase moving platforms
            if (customLevel.movingPlatforms) {
                customLevel.movingPlatforms = customLevel.movingPlatforms.filter(mp =>
                    !(x >= mp.x && x <= mp.x + mp.w && y >= mp.y && y <= mp.y + mp.h)
                );
            }
            // Erase flag
            if (customLevel.flag && x >= customLevel.flag.x && x <= customLevel.flag.x + 40 &&
                y >= customLevel.flag.y && y <= customLevel.flag.y + 48) {
                customLevel.flag = null;
            }
        }

        // Tool selection
        let selectedMovingPlatform = null;
        const movingSettings = document.getElementById('movingSettings');
        const mpRangeInput = document.getElementById('mpRange');
        const mpSpeedInput = document.getElementById('mpSpeed');
        const mpVerticalInput = document.getElementById('mpVertical');
        const selectedMpInfo = document.getElementById('selectedMpInfo');

        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                editorTool = btn.dataset.tool;
                selectedMovingPlatform = null;
                selectedMpInfo.textContent = '';

                // Show/hide moving platform settings
                if (editorTool === 'moving') {
                    movingSettings.style.display = 'block';
                } else {
                    movingSettings.style.display = 'none';
                }
            });
        });

        // Update selected moving platform when inputs change
        function updateSelectedMp() {
            if (selectedMovingPlatform) {
                selectedMovingPlatform.range = parseInt(mpRangeInput.value) || 80;
                selectedMovingPlatform.speed = parseFloat(mpSpeedInput.value) || 2;
                selectedMovingPlatform.vertical = mpVerticalInput.checked;
            }
        }
        mpRangeInput.addEventListener('input', updateSelectedMp);
        mpSpeedInput.addEventListener('input', updateSelectedMp);
        mpVerticalInput.addEventListener('change', updateSelectedMp);

        // Menu buttons
        document.getElementById('playBtn').addEventListener('click', () => {
            twoPlayerMode = false;
            chainedMode = false;
            mainMenu.style.display = 'none';
            levelDisplay.style.display = 'block';
            escBtn.style.display = 'block';
            document.getElementById('musicBtn').style.display = 'block';
            gameState = 'playing';
            currentLevel = 0;
            loadLevel(0);
            initAudio();
            startSpeedrun();
        });

        document.getElementById('twoPlayerBtn').addEventListener('click', () => {
            twoPlayerMode = true;
            chainedMode = false;
            mainMenu.style.display = 'none';
            levelDisplay.style.display = 'block';
            escBtn.style.display = 'block';
            document.getElementById('musicBtn').style.display = 'block';
            gameState = 'playing';
            currentLevel = 0;
            loadLevel(0);
            initAudio();
            startSpeedrun();
        });

        document.getElementById('chainedBtn').addEventListener('click', () => {
            twoPlayerMode = false;
            chainedMode = true;
            mainMenu.style.display = 'none';
            levelDisplay.style.display = 'block';
            escBtn.style.display = 'block';
            document.getElementById('musicBtn').style.display = 'block';
            gameState = 'playing';
            currentLevel = 0;
            loadLevel(0);
            initAudio();
            startSpeedrun();
        });

        document.getElementById('editorBtn').addEventListener('click', () => {
            mainMenu.style.display = 'none';
            showEditor();
            gameState = 'editor';
            canEdit = false;
            currentEditingIndex = -1;
            customLevel = {
                playerStart: { x: 64, y: 500 },
                platforms: [],
                spikes: [],
                lava: [],
                enemies: [],
                flag: null,
                movingPlatforms: [],
                stickyPlatforms: [],
                bouncyPlatforms: []
            };
            document.getElementById('newLevelName').value = '';
        });

        document.getElementById('howToPlayBtn').addEventListener('click', () => {
            howToPlay.style.display = 'flex';
        });

        document.getElementById('backFromHowTo').addEventListener('click', () => {
            howToPlay.style.display = 'none';
        });

        document.getElementById('testLevelBtn').addEventListener('click', () => {
            if (!customLevel.flag) {
                alert('Please place a flag first!');
                return;
            }
            hideEditor();
            levelDisplay.style.display = 'block';
            escBtn.style.display = 'block';
            document.getElementById('musicBtn').style.display = 'block';
            levelDisplay.textContent = 'Custom Level';
            initAudio();
            gameState = 'testing';
            level = JSON.parse(JSON.stringify(customLevel));
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.vx = 0;
            player.vy = 0;
            player.dead = false;
            enemies = level.enemies.map(e => ({
                x: e.x,
                y: e.y,
                startX: e.x,
                patrol: e.patrol,
                width: 30,
                height: 30,
                vx: 1.5,
                direction: 1
            }));

            // Initialize moving platforms
            level.movingPlatforms = level.movingPlatforms || [];
            level.movingPlatforms.forEach(mp => {
                mp.startX = mp.x;
                mp.startY = mp.y;
                mp.offset = 0;
                mp.dir = 1;
            });

            // Initialize sticky platforms
            level.stickyPlatforms = level.stickyPlatforms || [];

            // Initialize bouncy platforms
            level.bouncyPlatforms = level.bouncyPlatforms || [];
        });

        document.getElementById('backToMenuBtn').addEventListener('click', () => {
            hideEditor();
            mainMenu.style.display = 'flex';
            gameState = 'menu';
        });

        // Override levelComplete for testing mode
        const originalLevelComplete = levelComplete;
        levelComplete = function() {
            if (gameState === 'testing') {
                showMessage(
                    'Level Complete!',
                    'Your custom level works!',
                    'Back to Editor',
                    () => {
                        levelDisplay.style.display = 'none';
                        escBtn.style.display = 'none';
                        document.getElementById('musicBtn').style.display = 'none';
                        showEditor();
                        gameState = 'editor';
                        stopMusic();
                        document.getElementById('musicBtn').textContent = 'Music: OFF';
                        document.getElementById('musicBtn').classList.remove('on');
                    }
                );
            } else {
                originalLevelComplete();
            }
        };

        // Music button click handler
        const musicBtn = document.getElementById('musicBtn');
        musicBtn.addEventListener('click', () => {
            initAudio();
            toggleMusic();
            if (musicPlaying) {
                musicBtn.textContent = 'Music: ON';
                musicBtn.classList.add('on');
            } else {
                musicBtn.textContent = 'Music: OFF';
                musicBtn.classList.remove('on');
            }
        });

        // ESC button click handler
        escBtn.addEventListener('click', () => {
            if (gameState === 'testing') {
                message.style.display = 'none';
                levelDisplay.style.display = 'none';
                escBtn.style.display = 'none';
                musicBtn.style.display = 'none';
                showEditor();
                gameState = 'editor';
                resetPlayer();
                stopMusic();
                musicBtn.textContent = 'Music: OFF';
                musicBtn.classList.remove('on');
            } else if (gameState === 'playing') {
                message.style.display = 'none';
                levelDisplay.style.display = 'none';
                escBtn.style.display = 'none';
                musicBtn.style.display = 'none';
                document.getElementById('timerDisplay').style.display = 'none';
                mainMenu.style.display = 'flex';
                gameState = 'menu';
                stopMusic();
                resetSpeedrun();
                levelCompleted = false;
                musicBtn.textContent = 'Music: OFF';
                musicBtn.classList.remove('on');
            }
        });

        // Handle ESC key to return to menu/editor
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                if (gameState === 'testing') {
                    message.style.display = 'none';
                    levelDisplay.style.display = 'none';
                    escBtn.style.display = 'none';
                    musicBtn.style.display = 'none';
                    showEditor();
                    gameState = 'editor';
                    resetPlayer();
                    stopMusic();
                    musicBtn.textContent = 'Music: OFF';
                    musicBtn.classList.remove('on');
                } else if (gameState === 'playing') {
                    message.style.display = 'none';
                    levelDisplay.style.display = 'none';
                    escBtn.style.display = 'none';
                    musicBtn.style.display = 'none';
                    document.getElementById('timerDisplay').style.display = 'none';
                    mainMenu.style.display = 'flex';
                    gameState = 'menu';
                    stopMusic();
                    resetSpeedrun();
                    levelCompleted = false;
                    musicBtn.textContent = 'Music: OFF';
                    musicBtn.classList.remove('on');
                }
            }
        });

        // Level management functions
        function saveLevels() {
            localStorage.setItem('jumpGameLevels', JSON.stringify(savedLevels));
        }

        function renderLevelList() {
            const levelList = document.getElementById('levelList');
            levelList.innerHTML = '';

            savedLevels.forEach((lvl, index) => {
                const item = document.createElement('div');
                item.className = 'level-item' + (index === currentEditingIndex ? ' active' : '');
                item.innerHTML = `
                    <span class="level-name">${lvl.name}</span>
                    <div class="level-item-btns">
                        <button class="play-btn" data-index="${index}">Play</button>
                        <button class="edit-btn" data-index="${index}">Edit</button>
                        <button class="delete" data-index="${index}">X</button>
                    </div>
                `;
                levelList.appendChild(item);
            });

            // Add event listeners
            levelList.querySelectorAll('.play-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(btn.dataset.index);
                    playCustomLevel(index);
                });
            });

            levelList.querySelectorAll('.edit-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(btn.dataset.index);
                    loadLevelForEditing(index);
                });
            });

            levelList.querySelectorAll('.delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(btn.dataset.index);
                    deleteLevel(index);
                });
            });
        }

        function loadLevelForEditing(index) {
            currentEditingIndex = index;
            customLevel = JSON.parse(JSON.stringify(savedLevels[index].data));
            document.getElementById('newLevelName').value = savedLevels[index].name;
            canEdit = true;
            renderLevelList();
        }

        function playCustomLevel(index) {
            const lvl = savedLevels[index];
            if (!lvl.data.flag) {
                alert('This level has no flag!');
                return;
            }
            hideEditor();
            levelDisplay.style.display = 'block';
            escBtn.style.display = 'block';
            levelDisplay.textContent = lvl.name;
            gameState = 'testing';
            level = JSON.parse(JSON.stringify(lvl.data));
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.vx = 0;
            player.vy = 0;
            player.dead = false;
            enemies = level.enemies.map(e => ({
                x: e.x,
                y: e.y,
                startX: e.x,
                patrol: e.patrol,
                width: 30,
                height: 30,
                vx: 1.5,
                direction: 1
            }));
        }

        function deleteLevel(index) {
            if (confirm('Delete "' + savedLevels[index].name + '"?')) {
                savedLevels.splice(index, 1);
                saveLevels();
                if (currentEditingIndex === index) {
                    currentEditingIndex = -1;
                    clearCurrentLevel();
                } else if (currentEditingIndex > index) {
                    currentEditingIndex--;
                }
                renderLevelList();
            }
        }

        function clearCurrentLevel() {
            customLevel = {
                playerStart: { x: 64, y: 500 },
                platforms: [{ x: 0, y: 608, w: 960, h: 32 }],
                stickyPlatforms: [],
                bouncyPlatforms: [],
                spikes: [],
                lava: [],
                enemies: [],
                flag: null,
                movingPlatforms: []
            };
            document.getElementById('newLevelName').value = '';
        }

        // Save level button
        document.getElementById('saveLevelBtn').addEventListener('click', () => {
            const nameInput = document.getElementById('newLevelName');
            const name = nameInput.value.trim() || 'Untitled Level';

            const levelData = {
                name: name,
                data: JSON.parse(JSON.stringify(customLevel))
            };

            if (currentEditingIndex >= 0) {
                // Update existing level
                savedLevels[currentEditingIndex] = levelData;
            } else {
                // Add new level
                savedLevels.push(levelData);
                currentEditingIndex = savedLevels.length - 1;
            }

            saveLevels();
            renderLevelList();
            nameInput.value = name;
        });

        // Clear all button
        document.getElementById('clearLevelBtn').addEventListener('click', () => {
            clearCurrentLevel();
        });

        // New level button - creates a new level entry immediately
        document.getElementById('newLevelBtn').addEventListener('click', () => {
            // Create new level with default name
            const newLevelData = {
                name: 'New Level ' + (savedLevels.length + 1),
                data: {
                    playerStart: { x: 64, y: 500 },
                    platforms: [{ x: 0, y: 608, w: 960, h: 32 }],
                    stickyPlatforms: [],
                    bouncyPlatforms: [],
                    spikes: [],
                    lava: [],
                    enemies: [],
                    flag: null,
                    movingPlatforms: []
                }
            };

            savedLevels.push(newLevelData);
            saveLevels();

            // Load the new level for editing
            currentEditingIndex = savedLevels.length - 1;
            customLevel = JSON.parse(JSON.stringify(newLevelData.data));
            document.getElementById('newLevelName').value = newLevelData.name;
            canEdit = true;

            renderLevelList();
        });

        // Initialize level list on editor open
        const originalEditorBtn = document.getElementById('editorBtn');
        originalEditorBtn.addEventListener('click', () => {
            renderLevelList();
        });

        // Level code copy/import functionality
        let isImportMode = false;

        function getLevelCode() {
            const levelData = {
                name: document.getElementById('newLevelName').value.trim() || 'Untitled Level',
                playerStart: customLevel.playerStart,
                platforms: customLevel.platforms,
                stickyPlatforms: customLevel.stickyPlatforms || [],
                bouncyPlatforms: customLevel.bouncyPlatforms || [],
                spikes: customLevel.spikes,
                lava: customLevel.lava,
                enemies: customLevel.enemies,
                flag: customLevel.flag,
                movingPlatforms: customLevel.movingPlatforms || []
            };
            return JSON.stringify(levelData, null, 2);
        }

        function importLevelFromCode(code) {
            try {
                const data = JSON.parse(code);
                if (!data.playerStart || !data.platforms) {
                    throw new Error('Invalid level format');
                }
                customLevel = {
                    playerStart: data.playerStart || { x: 64, y: 500 },
                    platforms: data.platforms || [],
                    stickyPlatforms: data.stickyPlatforms || [],
                    bouncyPlatforms: data.bouncyPlatforms || [],
                    spikes: data.spikes || [],
                    lava: data.lava || [],
                    enemies: data.enemies || [],
                    flag: data.flag || null,
                    movingPlatforms: data.movingPlatforms || []
                };
                document.getElementById('newLevelName').value = data.name || 'Imported Level';
                currentEditingIndex = -1;
                renderLevelList();
                return true;
            } catch (e) {
                alert('Invalid level code! Please check the format and try again.');
                return false;
            }
        }

        document.getElementById('copyLevelBtn').addEventListener('click', () => {
            isImportMode = false;
            document.getElementById('levelCodeTitle').textContent = 'Level Code';
            document.getElementById('levelCodeDesc').textContent = 'Copy this code to share your level with others.';
            document.getElementById('levelCodeText').value = getLevelCode();
            document.getElementById('levelCodeText').readOnly = true;
            document.getElementById('copyToClipboardBtn').style.display = 'block';
            document.getElementById('importFromCodeBtn').style.display = 'none';
            document.getElementById('levelCodeModal').style.display = 'flex';
        });

        document.getElementById('importLevelBtn').addEventListener('click', () => {
            isImportMode = true;
            document.getElementById('levelCodeTitle').textContent = 'Import Level';
            document.getElementById('levelCodeDesc').textContent = 'Paste a level code below to import it.';
            document.getElementById('levelCodeText').value = '';
            document.getElementById('levelCodeText').readOnly = false;
            document.getElementById('levelCodeText').placeholder = 'Paste level code here...';
            document.getElementById('copyToClipboardBtn').style.display = 'none';
            document.getElementById('importFromCodeBtn').style.display = 'block';
            document.getElementById('levelCodeModal').style.display = 'flex';
            document.getElementById('levelCodeText').focus();
        });

        document.getElementById('copyToClipboardBtn').addEventListener('click', () => {
            const textarea = document.getElementById('levelCodeText');
            textarea.select();
            document.execCommand('copy');
            document.getElementById('copyToClipboardBtn').textContent = 'Copied!';
            setTimeout(() => {
                document.getElementById('copyToClipboardBtn').textContent = 'Copy to Clipboard';
            }, 2000);
        });

        document.getElementById('importFromCodeBtn').addEventListener('click', () => {
            const code = document.getElementById('levelCodeText').value;
            if (importLevelFromCode(code)) {
                document.getElementById('levelCodeModal').style.display = 'none';
            }
        });

        document.getElementById('closeLevelCodeBtn').addEventListener('click', () => {
            document.getElementById('levelCodeModal').style.display = 'none';
        });

        // Leaderboard button
        document.getElementById('leaderboardBtn').addEventListener('click', () => {
            mainMenu.style.display = 'none';
            renderLeaderboard();
            document.getElementById('leaderboard').style.display = 'flex';
        });

        document.getElementById('backFromLeaderboard').addEventListener('click', () => {
            document.getElementById('leaderboard').style.display = 'none';
            mainMenu.style.display = 'flex';
        });

        // Achievements button
        // Helper to update customize UI for current player
        function updateCustomizeUI() {
            const custom = editingPlayer === 1 ? characterCustomization : player2Customization;
            document.getElementById('bodyColor').value = custom.bodyColor;
            document.getElementById('skinColor').value = custom.skinColor;
            document.getElementById('eyeColor').value = custom.eyeColor;
            document.querySelectorAll('.accessory-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.accessory === custom.accessory);
            });
            document.getElementById('p1Tab').classList.toggle('selected', editingPlayer === 1);
            document.getElementById('p2Tab').classList.toggle('selected', editingPlayer === 2);
            drawCharacterPreview();
        }

        // Customize button
        document.getElementById('customizeBtn').addEventListener('click', () => {
            mainMenu.style.display = 'none';
            editingPlayer = 1;
            updateCustomizeUI();
            document.getElementById('customize').style.display = 'flex';
        });

        // Player tab switching
        document.getElementById('p1Tab').addEventListener('click', () => {
            editingPlayer = 1;
            updateCustomizeUI();
        });

        document.getElementById('p2Tab').addEventListener('click', () => {
            editingPlayer = 2;
            updateCustomizeUI();
        });

        document.getElementById('backFromCustomize').addEventListener('click', () => {
            saveCustomization();
            document.getElementById('customize').style.display = 'none';
            mainMenu.style.display = 'flex';
        });

        // Color picker listeners
        document.getElementById('bodyColor').addEventListener('input', (e) => {
            setCurrentCustomization('bodyColor', e.target.value);
            drawCharacterPreview();
        });

        document.getElementById('skinColor').addEventListener('input', (e) => {
            setCurrentCustomization('skinColor', e.target.value);
            drawCharacterPreview();
        });

        document.getElementById('eyeColor').addEventListener('input', (e) => {
            setCurrentCustomization('eyeColor', e.target.value);
            drawCharacterPreview();
        });

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setCurrentCustomization('bodyColor', btn.dataset.body);
                setCurrentCustomization('skinColor', btn.dataset.skin);
                setCurrentCustomization('eyeColor', btn.dataset.eye);
                document.getElementById('bodyColor').value = btn.dataset.body;
                document.getElementById('skinColor').value = btn.dataset.skin;
                document.getElementById('eyeColor').value = btn.dataset.eye;
                drawCharacterPreview();
            });
        });

        // Accessory button handlers
        document.querySelectorAll('.accessory-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.accessory-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                setCurrentCustomization('accessory', btn.dataset.accessory);
                saveCustomization();
                drawCharacterPreview();
            });
        });

        // Name entry handlers
        document.getElementById('saveScoreBtn').addEventListener('click', async () => {
            const name = document.getElementById('playerName').value.trim() || 'Anonymous';
            document.getElementById('nameEntry').style.display = 'none';
            levelDisplay.style.display = 'none';
            escBtn.style.display = 'none';
            document.getElementById('musicBtn').style.display = 'none';
            document.getElementById('timerDisplay').style.display = 'none';
            stopMusic();
            document.getElementById('musicBtn').textContent = 'Music: OFF';
            document.getElementById('musicBtn').classList.remove('on');
            document.getElementById('leaderboard').style.display = 'flex';
            gameState = 'menu';
            levelCompleted = false;
            await saveToLeaderboard(name, speedrunTime);
            await renderLeaderboard();
        });

        document.getElementById('skipScoreBtn').addEventListener('click', () => {
            document.getElementById('nameEntry').style.display = 'none';
            levelDisplay.style.display = 'none';
            escBtn.style.display = 'none';
            document.getElementById('musicBtn').style.display = 'none';
            document.getElementById('timerDisplay').style.display = 'none';
            mainMenu.style.display = 'flex';
            stopMusic();
            document.getElementById('musicBtn').textContent = 'Music: OFF';
            document.getElementById('musicBtn').classList.remove('on');
            gameState = 'menu';
            levelCompleted = false;
        });

        // Allow pressing Enter to save score
        document.getElementById('playerName').addEventListener('keydown', (e) => {
            if (e.code === 'Enter') {
                document.getElementById('saveScoreBtn').click();
            }
        });

        // Start the game loop (menu is shown by default)
        gameState = 'menu';
        renderLevelList();
        gameLoop();
    </script>
</body>
</html>
