<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ice Hockey</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a1a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Segoe UI', Arial, sans-serif;
    overflow: hidden;
  }
  #gameContainer { position: relative; width: 800px; height: 520px; }
  canvas { display: block; border-radius: 6px; }
  #overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(5, 5, 20, 0.93);
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    z-index: 10;
  }
  #overlay.hidden { display: none; }
  #overlay h1 {
    font-size: 46px; color: #fff; letter-spacing: 5px;
    text-transform: uppercase; margin-bottom: 6px;
  }
  #overlay .sub { color: #888; font-size: 14px; margin-bottom: 36px; }
  .controls { display: flex; gap: 50px; margin-bottom: 36px; }
  .ctrl {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px; padding: 18px 26px; text-align: center;
  }
  .ctrl h3 { font-size: 12px; letter-spacing: 2px; margin-bottom: 10px; }
  .ctrl p { color: #aaa; font-size: 13px; line-height: 2; }
  .red { color: #e05050; }
  .blue { color: #5090ee; }
  .mode-btns { display: flex; gap: 16px; }
  .mode-btn {
    background: #2a2a4a; border: 2px solid #444; color: #fff;
    font-size: 15px; padding: 13px 36px; border-radius: 8px;
    cursor: pointer; letter-spacing: 2px; text-transform: uppercase;
    transition: background 0.15s, border-color 0.15s;
  }
  .mode-btn:hover { background: #3a3a6a; border-color: #667eea; }
  .mode-btn.active { background: #667eea; border-color: #667eea; }
  #trainingView { display:none; text-align:center; }
  #trainingView p { color:#aaa; margin-bottom:16px; font-size:14px; letter-spacing:1px; }
  #trainingGenText { color:#fff; font-size:16px; margin-bottom:14px; }
  #trainingBarWrap { background:#1a1a3a; border-radius:6px; height:8px; width:300px; overflow:hidden; margin:0 auto 30px; }
  #trainingBar { background:#667eea; height:100%; width:0%; transition:width 0.1s; }
  #playBtn {
    margin-top: 20px;
    background: #667eea; border: none; color: #fff;
    font-size: 16px; padding: 13px 48px; border-radius: 8px;
    cursor: pointer; letter-spacing: 3px; text-transform: uppercase;
  }
  #playBtn:hover { background: #5568d6; }
  #goalMsg {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.88);
    color: #fff; font-size: 42px; font-weight: bold;
    padding: 18px 50px; border-radius: 12px;
    display: none; z-index: 20; letter-spacing: 4px;
    text-shadow: 0 0 24px rgba(255,200,0,0.9);
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="canvas" width="800" height="520"></canvas>
  <div id="overlay">
    <h1 id="overlayTitle">Ice Hockey</h1>
    <p class="sub" id="overlaySub">First to 5 goals wins</p>
    <div class="controls">
      <div class="ctrl">
        <h3 class="red">PLAYER 1</h3>
        <p>WASD — Move</p>
      </div>
      <div class="ctrl" id="p2ctrl">
        <h3 class="blue">PLAYER 2</h3>
        <p>Arrow Keys — Move</p>
      </div>
    </div>
    <div id="menuView">
      <div class="mode-btns">
        <button class="mode-btn active" id="twoPlayerBtn">2 Players</button>
        <button class="mode-btn" id="botBtn">vs Bot</button>
        <button class="mode-btn" id="learnBtn">Learning Bot</button>
      </div>
      <button id="playBtn">PLAY</button>
    </div>
    <div id="trainingView">
      <p>Bot is playing matches against itself...</p>
      <div id="trainingGenText">Generation 0 / 100</div>
      <div id="trainingBarWrap"><div id="trainingBar"></div></div>
    </div>
  </div>
  <div id="goalMsg">GOAL!</div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 800, H = 520;

// Rink layout
const RX = 30, RY = 65, RW = 740, RH = 390;
const GOAL_DEPTH = 14, GOAL_H = 92;
const GOAL_Y1 = RY + RH/2 - GOAL_H/2;
const GOAL_Y2 = RY + RH/2 + GOAL_H/2;

// Constants
const PR = 20;        // player radius
const PUCK_R = 7;     // puck radius
const PLAYER_FRIC = 0.979;
const PUCK_FRIC = 0.990;
const PUCK_MAX = 30;
const STICK_LEN = 42;
const STICK_R = 3;
const WIN = 5;

let score = [0, 0];
let phase = 'menu'; // menu, playing, goal, over
let goalTimer = 0;
let gameMode = 'twoPlayer'; // 'twoPlayer' or 'vsBot'

function mkPlayer(x, y, color, keys, initAngle = 0) {
  return { x, y, vx: 0, vy: 0, color, keys, angle: initAngle, dx: Math.cos(initAngle), dy: Math.sin(initAngle), stun: 0 };
}

function lerpAngle(a, b, t) {
  let d = b - a;
  while (d > Math.PI) d -= Math.PI * 2;
  while (d < -Math.PI) d += Math.PI * 2;
  return a + d * t;
}

let p1, p2, puck;
let botKickoffOffset = 0;

// ===== LEARNING BOT =====
let evolvedGenome = null;
let trainingGen = 0;
const TRAINING_GENS = 500;

function randomGenome() {
  return {
    lookahead:    5 + Math.random() * 15,
    behindOffset: 10 + Math.random() * 50,
    nearThresh:   40 + Math.random() * 80,
  };
}

function mutateGenome(g) {
  return {
    lookahead:    Math.max(0,  Math.min(25,  g.lookahead    + (Math.random()-0.5) * 6)),
    behindOffset: Math.max(5,  Math.min(80,  g.behindOffset + (Math.random()-0.5) * 12)),
    nearThresh:   Math.max(30, Math.min(150, g.nearThresh   + (Math.random()-0.5) * 20)),
  };
}

// Shared decision function used by both live bot and simulator
function botDecision(genome, bot, pk, goalX, goalY) {
  const tpx = Math.max(RX+PR, Math.min(RX+RW-PR, pk.x + pk.vx * genome.lookahead));
  const tpy = Math.max(RY+PR, Math.min(RY+RH-PR, pk.y + pk.vy * genome.lookahead));
  const puckDist = Math.hypot(pk.x - bot.x, pk.y - bot.y);
  let tx, ty;
  if (puckDist < genome.nearThresh) {
    const pgDx = goalX - pk.x, pgDy = goalY - pk.y;
    const pgDist = Math.hypot(pgDx, pgDy) || 1;
    tx = Math.max(RX+PR, Math.min(RX+RW-PR, pk.x - (pgDx/pgDist) * genome.behindOffset));
    ty = Math.max(RY+PR, Math.min(RY+RH-PR, pk.y - (pgDy/pgDist) * genome.behindOffset));
  } else {
    tx = tpx; ty = tpy;
  }
  const dx = tx - bot.x, dy = ty - bot.y, d = Math.hypot(dx, dy);
  return d > 6 ? [dx/d, dy/d] : [0, 0];
}

// Simulation helpers (mirrors game physics without rendering)
function simMove(p, mx, my) {
  if (mx !== 0 || my !== 0) {
    p.angle = lerpAngle(p.angle, Math.atan2(my, mx), 0.15);
    p.vx += mx * 0.12; p.vy += my * 0.12;
  }
  p.dx = Math.cos(p.angle); p.dy = Math.sin(p.angle);
  p.x += p.vx; p.y += p.vy;
  p.vx *= PLAYER_FRIC; p.vy *= PLAYER_FRIC;
  if (p.x-PR < RX)     { p.x = RX+PR;     p.vx =  Math.abs(p.vx)*0.5; }
  if (p.x+PR > RX+RW)  { p.x = RX+RW-PR;  p.vx = -Math.abs(p.vx)*0.5; }
  if (p.y-PR < RY)     { p.y = RY+PR;      p.vy =  Math.abs(p.vy)*0.5; }
  if (p.y+PR > RY+RH)  { p.y = RY+RH-PR;  p.vy = -Math.abs(p.vy)*0.5; }
}

function simBodyCheck(a, b) {
  const dx = b.x-a.x, dy = b.y-a.y, dist = Math.hypot(dx,dy);
  if (dist >= PR*2 || dist === 0) return;
  const nx = dx/dist, ny = dy/dist, ov = PR*2-dist;
  a.x -= nx*ov/2; a.y -= ny*ov/2; b.x += nx*ov/2; b.y += ny*ov/2;
  const s1 = Math.hypot(a.vx,a.vy), s2 = Math.hypot(b.vx,b.vy);
  if (s1>2.5 && (a.vx*nx+a.vy*ny)>0)     { b.vx+=nx*s1*0.9; b.vy+=ny*s1*0.9; a.vx*=0.4; a.vy*=0.4; }
  if (s2>2.5 && (b.vx*(-nx)+b.vy*(-ny))>0){ a.vx-=nx*s2*0.9; a.vy-=ny*s2*0.9; b.vx*=0.4; b.vy*=0.4; }
}

function simStick(p, pk) {
  const offX=p.dy*PR*0.7, offY=-p.dx*PR*0.7;
  const sx=p.x+p.dx*PR*0.4+offX, sy=p.y+p.dy*PR*0.4+offY;
  const ex=sx+p.dx*STICK_LEN, ey=sy+p.dy*STICK_LEN;
  const sdx=ex-sx, sdy=ey-sy, sl2=sdx*sdx+sdy*sdy;
  let t=((pk.x-sx)*sdx+(pk.y-sy)*sdy)/sl2;
  t=Math.max(0,Math.min(1,t));
  const cx=sx+t*sdx, cy=sy+t*sdy, dx=pk.x-cx, dy=pk.y-cy, dist=Math.hypot(dx,dy), min=PUCK_R+STICK_R;
  if (dist<min && dist>0) {
    const nx=dx/dist, ny=dy/dist;
    pk.x=cx+nx*min; pk.y=cy+ny*min;
    const rd=(pk.vx-p.vx)*nx+(pk.vy-p.vy)*ny;
    if (rd<0) { pk.vx-=rd*nx*1.8; pk.vy-=rd*ny*1.8; pk.vx+=p.vx*0.4; pk.vy+=p.vy*0.4; }
  }
}

function simBodyPuck(p, pk) {
  const dx=pk.x-p.x, dy=pk.y-p.y, dist=Math.hypot(dx,dy);
  if (dist<PR+PUCK_R && dist>0) {
    const nx=dx/dist, ny=dy/dist;
    pk.x=p.x+nx*(PR+PUCK_R); pk.y=p.y+ny*(PR+PUCK_R);
    const d=(pk.vx-p.vx)*nx+(pk.vy-p.vy)*ny;
    if (d<0) { pk.vx-=d*nx; pk.vy-=d*ny; }
  }
}

function simPuck(pk) {
  pk.x+=pk.vx; pk.y+=pk.vy; pk.vx*=PUCK_FRIC; pk.vy*=PUCK_FRIC;
  if (pk.x-PUCK_R<RX   && (pk.y<GOAL_Y1||pk.y>GOAL_Y2)) { pk.x=RX+PUCK_R;     pk.vx= Math.abs(pk.vx)*0.7; }
  if (pk.x+PUCK_R>RX+RW && (pk.y<GOAL_Y1||pk.y>GOAL_Y2)) { pk.x=RX+RW-PUCK_R; pk.vx=-Math.abs(pk.vx)*0.7; }
  if (pk.y-PUCK_R<RY)  { pk.y=RY+PUCK_R;    pk.vy= Math.abs(pk.vy)*0.7; }
  if (pk.y+PUCK_R>RY+RH){ pk.y=RY+RH-PUCK_R; pk.vy=-Math.abs(pk.vy)*0.7; }
  if (pk.y>=GOAL_Y1&&pk.y<=GOAL_Y2) {
    if (pk.x-PUCK_R<RX-GOAL_DEPTH)    { pk.x=RX-GOAL_DEPTH+PUCK_R;    pk.vx= Math.abs(pk.vx)*0.5; }
    if (pk.x+PUCK_R>RX+RW+GOAL_DEPTH) { pk.x=RX+RW+GOAL_DEPTH-PUCK_R; pk.vx=-Math.abs(pk.vx)*0.5; }
  }
  const sp=Math.hypot(pk.vx,pk.vy); if (sp>PUCK_MAX) { pk.vx=pk.vx/sp*PUCK_MAX; pk.vy=pk.vy/sp*PUCK_MAX; }
}

function simReset(a, b, pk) {
  a.x=RX+160;     a.y=RY+RH/2; a.vx=0; a.vy=0; a.angle=0;      a.dx=1;  a.dy=0;
  b.x=RX+RW-160;  b.y=RY+RH/2; b.vx=0; b.vy=0; b.angle=Math.PI; b.dx=-1; b.dy=0;
  pk.x=RX+RW/2; pk.y=RY+RH/2; pk.vx=0; pk.vy=0;
}

// Simulate a match between two genomes; returns 'A' or 'B'
function simulateMatch(gA, gB) {
  const a  = { x:RX+160,    y:RY+RH/2, vx:0, vy:0, angle:0,      dx:1,  dy:0 };
  const b  = { x:RX+RW-160, y:RY+RH/2, vx:0, vy:0, angle:Math.PI, dx:-1, dy:0 };
  const pk = { x:RX+RW/2,   y:RY+RH/2, vx:0, vy:0 };
  let sa=0, sb=0;
  for (let f=0; f<3600; f++) {
    const [ax,ay] = botDecision(gA, a, pk, RX+RW-10, RY+RH/2); simMove(a, ax, ay);
    const [bx,by] = botDecision(gB, b, pk, RX+10,    RY+RH/2); simMove(b, bx, by);
    simBodyCheck(a, b);
    simPuck(pk);
    simBodyPuck(a,pk); simBodyPuck(b,pk);
    simStick(a,pk);    simStick(b,pk);
    if (pk.y>=GOAL_Y1 && pk.y<=GOAL_Y2) {
      if (pk.x<RX-4)     { sb++; simReset(a,b,pk); }
      else if (pk.x>RX+RW+4) { sa++; simReset(a,b,pk); }
    }
    if (sa>=3 || sb>=3) break;
  }
  if (sa > sb) return 'A';
  if (sb > sa) return 'B';
  return null;
}

function runTraining() {
  trainingGen = 0;
  let champion = randomGenome();
  let challenger = mutateGenome(champion);
  document.getElementById('menuView').style.display = 'none';
  document.getElementById('trainingView').style.display = 'block';
  document.getElementById('overlay').classList.remove('hidden');

  function step() {
    const BATCH = 8;
    for (let i=0; i<BATCH && trainingGen<TRAINING_GENS; i++) {
      // Play both sides for fairness
      const w1 = simulateMatch(champion, challenger);
      const w2 = simulateMatch(challenger, champion);
      const challengerWins = (w1==='B'?1:0) + (w2==='A'?1:0);
      if (challengerWins >= 2) champion = challenger;
      challenger = mutateGenome(champion);
      trainingGen++;
    }
    const pct = (trainingGen / TRAINING_GENS * 100).toFixed(0);
    document.getElementById('trainingBar').style.width = pct + '%';
    document.getElementById('trainingGenText').textContent = `Generation ${trainingGen} / ${TRAINING_GENS}`;

    if (trainingGen >= TRAINING_GENS) {
      evolvedGenome = champion;
      document.getElementById('menuView').style.display = '';
      document.getElementById('trainingView').style.display = 'none';
      startGame('vsLearningBot');
    } else {
      requestAnimationFrame(step);
    }
  }
  requestAnimationFrame(step);
}

function reset() {
  p1 = mkPlayer(RX + 160, RY + RH/2, '#e05050', { up:'w', dn:'s', lt:'a', rt:'d' }, 0);
  p2 = mkPlayer(RX + RW - 160, RY + RH/2, '#5090ee', { up:'ArrowUp', dn:'ArrowDown', lt:'ArrowLeft', rt:'ArrowRight' }, Math.PI);
  puck = { x: RX + RW/2, y: RY + RH/2, vx: 0, vy: 0 };
  // Random lateral offset so bot doesn't charge straight at kickoff
  botKickoffOffset = (Math.random() - 0.5) * 80;
}

const keys = {};
window.addEventListener('keydown', e => {
  if (!keys[e.key]) {
    keys[e.key] = true;
    if ([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
  }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

function getStick(p) {
  // Offset to player's right side: perpendicular is (dy, -dx)
  const offX = p.dy * PR * 0.7, offY = -p.dx * PR * 0.7;
  const sx = p.x + p.dx * PR * 0.4 + offX;
  const sy = p.y + p.dy * PR * 0.4 + offY;
  return { sx, sy, ex: sx + p.dx * STICK_LEN, ey: sy + p.dy * STICK_LEN };
}

function stickHitPuck(p) {
  const { sx, sy, ex, ey } = getStick(p);
  const segDx = ex - sx, segDy = ey - sy;

  const segLen2 = segDx*segDx + segDy*segDy;
  let t = ((puck.x - sx)*segDx + (puck.y - sy)*segDy) / segLen2;
  t = Math.max(0, Math.min(1, t));
  const cx = sx + t*segDx, cy = sy + t*segDy;
  const dx = puck.x - cx, dy = puck.y - cy;
  const dist = Math.hypot(dx, dy);
  const minDist = PUCK_R + STICK_R;
  if (dist < minDist && dist > 0) {
    const nx = dx/dist, ny = dy/dist;
    puck.x = cx + nx * minDist;
    puck.y = cy + ny * minDist;
    const relDot = (puck.vx - p.vx)*nx + (puck.vy - p.vy)*ny;
    if (relDot < 0) {
      puck.vx -= relDot * nx * 1.8;
      puck.vy -= relDot * ny * 1.8;
      puck.vx += p.vx * 0.4;
      puck.vy += p.vy * 0.4;
    }
  }
}

function clampToRink(p) {
  if (p.x - PR < RX)       { p.x = RX + PR;       p.vx =  Math.abs(p.vx) * 0.5; }
  if (p.x + PR > RX + RW)  { p.x = RX + RW - PR;  p.vx = -Math.abs(p.vx) * 0.5; }
  if (p.y - PR < RY)       { p.y = RY + PR;        p.vy =  Math.abs(p.vy) * 0.5; }
  if (p.y + PR > RY + RH)  { p.y = RY + RH - PR;  p.vy = -Math.abs(p.vy) * 0.5; }
}

function movePlayer(p) {
  if (p.stun > 0) {
    p.stun--;
    p.x += p.vx; p.y += p.vy;
    p.vx *= PLAYER_FRIC; p.vy *= PLAYER_FRIC;
    clampToRink(p);
    return;
  }
  let mx = 0, my = 0;
  if (keys[p.keys.up]) my -= 1;
  if (keys[p.keys.dn]) my += 1;
  if (keys[p.keys.lt]) mx -= 1;
  if (keys[p.keys.rt]) mx += 1;
  if (mx !== 0 || my !== 0) {
    const len = Math.hypot(mx, my);
    mx /= len; my /= len;
    p.angle = lerpAngle(p.angle, Math.atan2(my, mx), 0.15);
    p.vx += mx * 0.12;
    p.vy += my * 0.12;
  }
  p.dx = Math.cos(p.angle);
  p.dy = Math.sin(p.angle);
  p.x += p.vx; p.y += p.vy;
  p.vx *= PLAYER_FRIC; p.vy *= PLAYER_FRIC;
  clampToRink(p);
}

function bodyCheck() {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const dist = Math.hypot(dx, dy);
  if (dist >= PR * 2) return;
  const nx = dx/dist, ny = dy/dist;
  const overlap = PR*2 - dist;
  p1.x -= nx * overlap/2; p1.y -= ny * overlap/2;
  p2.x += nx * overlap/2; p2.y += ny * overlap/2;

  const s1 = Math.hypot(p1.vx, p1.vy);
  const s2 = Math.hypot(p2.vx, p2.vy);

  // P1 checking P2
  if (s1 > 2.5 && (p1.vx*nx + p1.vy*ny) > 0) {
    p2.vx += nx * s1 * 0.9; p2.vy += ny * s1 * 0.9;
    p2.stun = 35;
    p1.vx *= 0.4; p1.vy *= 0.4;
  }
  // P2 checking P1
  if (s2 > 2.5 && (p2.vx*(-nx) + p2.vy*(-ny)) > 0) {
    p1.vx -= nx * s2 * 0.9; p1.vy -= ny * s2 * 0.9;
    p1.stun = 35;
    p2.vx *= 0.4; p2.vy *= 0.4;
  }
}

function updatePuck() {
  puck.x += puck.vx; puck.y += puck.vy;
  puck.vx *= PUCK_FRIC; puck.vy *= PUCK_FRIC;

  // Wall collisions — allow puck through goal openings
  if (puck.x - PUCK_R < RX) {
    if (puck.y < GOAL_Y1 || puck.y > GOAL_Y2) {
      puck.x = RX + PUCK_R; puck.vx = Math.abs(puck.vx) * 0.7;
    }
  }
  if (puck.x + PUCK_R > RX + RW) {
    if (puck.y < GOAL_Y1 || puck.y > GOAL_Y2) {
      puck.x = RX + RW - PUCK_R; puck.vx = -Math.abs(puck.vx) * 0.7;
    }
  }
  if (puck.y - PUCK_R < RY) { puck.y = RY + PUCK_R; puck.vy = Math.abs(puck.vy) * 0.7; }
  if (puck.y + PUCK_R > RY + RH) { puck.y = RY + RH - PUCK_R; puck.vy = -Math.abs(puck.vy) * 0.7; }

  // Goal back walls
  if (puck.y >= GOAL_Y1 && puck.y <= GOAL_Y2) {
    if (puck.x - PUCK_R < RX - GOAL_DEPTH) { puck.x = RX - GOAL_DEPTH + PUCK_R; puck.vx = Math.abs(puck.vx) * 0.5; }
    if (puck.x + PUCK_R > RX + RW + GOAL_DEPTH) { puck.x = RX + RW + GOAL_DEPTH - PUCK_R; puck.vx = -Math.abs(puck.vx) * 0.5; }
  }

  const pspd = Math.hypot(puck.vx, puck.vy);
  if (pspd > PUCK_MAX) { puck.vx = puck.vx/pspd * PUCK_MAX; puck.vy = puck.vy/pspd * PUCK_MAX; }

  // Body-puck collision
  for (const p of [p1, p2]) {
    const dx = puck.x - p.x, dy = puck.y - p.y;
    const dist = Math.hypot(dx, dy);
    if (dist < PR + PUCK_R && dist > 0) {
      const nx = dx/dist, ny = dy/dist;
      puck.x = p.x + nx * (PR + PUCK_R);
      puck.y = p.y + ny * (PR + PUCK_R);
      const dot = (puck.vx - p.vx)*nx + (puck.vy - p.vy)*ny;
      if (dot < 0) {
        puck.vx -= dot * nx;
        puck.vy -= dot * ny;
      }
    }
  }

  // Stick-puck collision
  stickHitPuck(p1);
  stickHitPuck(p2);
}

function checkGoal() {
  if (puck.y < GOAL_Y1 || puck.y > GOAL_Y2) return false;
  if (puck.x < RX - 4) { score[1]++; goal(); return true; }
  if (puck.x > RX + RW + 4) { score[0]++; goal(); return true; }
  return false;
}

function goal() {
  phase = 'goal';
  goalTimer = 130;
  const msg = document.getElementById('goalMsg');
  if (score[0] >= WIN || score[1] >= WIN) {
    msg.textContent = `Player ${score[0] >= WIN ? 1 : 2} Wins!`;
  } else {
    msg.textContent = 'GOAL!';
  }
  msg.style.display = 'block';
}

function updateBot(genome) {
  const bot = p2;
  if (bot.stun > 0) {
    bot.stun--;
    bot.x += bot.vx; bot.y += bot.vy;
    bot.vx *= PLAYER_FRIC; bot.vy *= PLAYER_FRIC;
    clampToRink(bot);
    return;
  }

  const goalX = RX + 10, goalY = RY + RH / 2;
  let [mx, my] = botDecision(genome, bot, puck, goalX, goalY);

  // Apply kickoff lateral offset for regular bot so it doesn't go dead straight
  if (gameMode === 'vsBot' && (mx !== 0 || my !== 0)) {
    const puckSpeed = Math.hypot(puck.vx, puck.vy);
    const fade = Math.max(0, 1 - puckSpeed / 3);
    const tx = bot.x + mx * 100;
    const ty = bot.y + my * 100 + botKickoffOffset * fade;
    const dx = tx - bot.x, dy = ty - bot.y, d = Math.hypot(dx, dy);
    if (d > 0) { mx = dx/d; my = dy/d; }
  }

  if (mx !== 0 || my !== 0) {
    bot.angle = lerpAngle(bot.angle, Math.atan2(my, mx), 0.15);
    bot.vx += mx * 0.12;
    bot.vy += my * 0.12;
  }
  bot.dx = Math.cos(bot.angle);
  bot.dy = Math.sin(bot.angle);
  bot.x += bot.vx; bot.y += bot.vy;
  bot.vx *= PLAYER_FRIC; bot.vy *= PLAYER_FRIC;
  clampToRink(bot);
}

const DEFAULT_GENOME = { lookahead: 12, behindOffset: PR + PUCK_R + 8, nearThresh: PR*2 + PUCK_R + STICK_LEN };

function update() {
  if (phase !== 'playing') return;
  movePlayer(p1);
  if (gameMode === 'vsBot') updateBot(DEFAULT_GENOME);
  else if (gameMode === 'vsLearningBot') updateBot(evolvedGenome);
  else movePlayer(p2);
  bodyCheck();
  updatePuck();
  checkGoal();
}

function tickGoal() {
  if (phase !== 'goal') return;
  goalTimer--;
  if (goalTimer > 0) return;
  document.getElementById('goalMsg').style.display = 'none';
  if (score[0] >= WIN || score[1] >= WIN) {
    phase = 'over';
    const winner = score[0] >= WIN ? 'Player 1' : (gameMode === 'vsBot' ? 'Bot' : gameMode === 'vsLearningBot' ? 'Learning Bot' : 'Player 2');
    document.getElementById('overlayTitle').textContent = `${winner} Wins!`;
    document.getElementById('overlaySub').textContent = `${score[0]} – ${score[1]}`;
    document.getElementById('overlay').classList.remove('hidden');
  } else {
    reset();
    phase = 'playing';
  }
}

// --- Drawing ---

function drawRink() {
  // Ice surface
  ctx.fillStyle = '#c9e9f5';
  ctx.beginPath();
  ctx.roundRect(RX, RY, RW, RH, 22);
  ctx.fill();

  // Clip to rink for lines
  ctx.save();
  ctx.beginPath();
  ctx.roundRect(RX, RY, RW, RH, 22);
  ctx.clip();

  // Blue lines
  ctx.strokeStyle = '#2255cc';
  ctx.lineWidth = 7;
  [0.25, 0.75].forEach(t => {
    ctx.beginPath();
    ctx.moveTo(RX + RW*t, RY);
    ctx.lineTo(RX + RW*t, RY + RH);
    ctx.stroke();
  });

  // Center red line
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(RX + RW/2, RY);
  ctx.lineTo(RX + RW/2, RY + RH);
  ctx.stroke();

  // Center circle
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(RX + RW/2, RY + RH/2, 44, 0, Math.PI*2);
  ctx.stroke();
  ctx.fillStyle = '#cc2222';
  ctx.beginPath();
  ctx.arc(RX + RW/2, RY + RH/2, 4, 0, Math.PI*2);
  ctx.fill();

  // Goal creases
  ctx.fillStyle = 'rgba(80,130,220,0.25)';
  ctx.fillRect(RX, GOAL_Y1, 55, GOAL_H);
  ctx.fillStyle = 'rgba(80,130,220,0.25)';
  ctx.fillRect(RX + RW - 55, GOAL_Y1, 55, GOAL_H);

  ctx.restore();

  // Rink border (red)
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(RX, RY, RW, RH, 22);
  ctx.stroke();

  // Goals
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 3;
  // Left goal
  ctx.strokeRect(RX - GOAL_DEPTH, GOAL_Y1, GOAL_DEPTH, GOAL_H);
  ctx.fillStyle = 'rgba(200,50,50,0.15)';
  ctx.fillRect(RX - GOAL_DEPTH, GOAL_Y1, GOAL_DEPTH, GOAL_H);
  // Right goal
  ctx.strokeRect(RX + RW, GOAL_Y1, GOAL_DEPTH, GOAL_H);
  ctx.fillStyle = 'rgba(200,50,50,0.15)';
  ctx.fillRect(RX + RW, GOAL_Y1, GOAL_DEPTH, GOAL_H);
}

function drawPlayer(p) {
  if (p.stun > 0 && Math.floor(p.stun/4) % 2 === 1) return;

  const { sx, sy, ex, ey } = getStick(p);
  const faceAngle = Math.atan2(p.dy, p.dx);

  // Stick (draw behind player body)
  ctx.strokeStyle = '#5a2d0c';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(sx, sy);
  ctx.lineTo(ex, ey);
  ctx.stroke();
  ctx.lineCap = 'butt';

  // Jersey (body circle)
  ctx.fillStyle = p.color;
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR, 0, Math.PI*2);
  ctx.fill();
  // Jersey outline
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Helmet (dark rounded cap, top-down view)
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR * 0.6, 0, Math.PI*2);
  ctx.fill();

  // Helmet color stripe (team color accent on helmet)
  ctx.strokeStyle = p.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR * 0.6, faceAngle - 1.1, faceAngle + 1.1);
  ctx.stroke();

  // Visor (light reflective arc on front of helmet)
  ctx.strokeStyle = 'rgba(200,230,255,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR * 0.6, faceAngle - 0.6, faceAngle + 0.6);
  ctx.stroke();
}

function drawPuck() {
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(puck.x, puck.y, PUCK_R, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawHUD() {
  // Background strip
  ctx.fillStyle = '#0d0d22';
  ctx.fillRect(0, 0, W, RY - 2);

  // P1 score
  ctx.fillStyle = '#e05050';
  ctx.font = 'bold 38px Segoe UI';
  ctx.textAlign = 'right';
  ctx.fillText(score[0], W/2 - 22, 50);

  // Dash
  ctx.fillStyle = '#555';
  ctx.textAlign = 'center';
  ctx.font = 'bold 28px Segoe UI';
  ctx.fillText('–', W/2, 48);

  // P2 score
  ctx.fillStyle = '#5090ee';
  ctx.textAlign = 'left';
  ctx.font = 'bold 38px Segoe UI';
  ctx.fillText(score[1], W/2 + 22, 50);

  // Labels
  ctx.font = '12px Segoe UI';
  ctx.fillStyle = '#e05050';
  ctx.textAlign = 'center';
  ctx.fillText('P1', RX + 80, RY - 8);
  ctx.fillStyle = '#5090ee';
  ctx.fillText('P2', RX + RW - 80, RY - 8);
}

function draw() {
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, W, H);
  drawRink();
  drawPlayer(p1);
  drawPlayer(p2);
  drawPuck();
  drawHUD();
}

function loop() {
  update();
  tickGoal();
  draw();
  requestAnimationFrame(loop);
}

function setActiveBtn(id) {
  ['twoPlayerBtn','botBtn','learnBtn'].forEach(b => document.getElementById(b).classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function startGame(mode) {
  gameMode = mode;
  score = [0, 0];
  reset();
  phase = 'playing';
  document.getElementById('overlayTitle').textContent = 'Ice Hockey';
  document.getElementById('overlaySub').textContent = 'First to 5 goals wins';
  document.getElementById('p2ctrl').style.display = (mode === 'vsBot' || mode === 'vsLearningBot') ? 'none' : '';
  document.getElementById('overlay').classList.add('hidden');
}

document.getElementById('twoPlayerBtn').addEventListener('click', () => {
  gameMode = 'twoPlayer'; setActiveBtn('twoPlayerBtn');
});
document.getElementById('botBtn').addEventListener('click', () => {
  gameMode = 'vsBot'; setActiveBtn('botBtn');
});
document.getElementById('learnBtn').addEventListener('click', () => {
  setActiveBtn('learnBtn');
  runTraining();
});
document.getElementById('playBtn').addEventListener('click', () => {
  if (gameMode !== 'vsLearningBot' || evolvedGenome) startGame(gameMode);
});

reset();
loop();
</script>
</body>
</html>
