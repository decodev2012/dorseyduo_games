<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ice Hockey</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a1a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Segoe UI', Arial, sans-serif;
    overflow: hidden;
  }
  #gameContainer { position: relative; width: 800px; height: 520px; }
  canvas { display: block; border-radius: 6px; }
  #overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(5, 5, 20, 0.93);
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    z-index: 10;
  }
  #overlay.hidden { display: none; }
  #overlay h1 {
    font-size: 46px; color: #fff; letter-spacing: 5px;
    text-transform: uppercase; margin-bottom: 6px;
  }
  #overlay .sub { color: #888; font-size: 14px; margin-bottom: 36px; }
  .controls { display: flex; gap: 50px; margin-bottom: 36px; }
  .ctrl {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px; padding: 18px 26px; text-align: center;
  }
  .ctrl h3 { font-size: 12px; letter-spacing: 2px; margin-bottom: 10px; }
  .ctrl p { color: #aaa; font-size: 13px; line-height: 2; }
  .red { color: #e05050; }
  .blue { color: #5090ee; }
  .mode-btns { display: flex; gap: 16px; }
  .mode-btn {
    background: #2a2a4a; border: 2px solid #444; color: #fff;
    font-size: 15px; padding: 13px 36px; border-radius: 8px;
    cursor: pointer; letter-spacing: 2px; text-transform: uppercase;
    transition: background 0.15s, border-color 0.15s;
  }
  .mode-btn:hover { background: #3a3a6a; border-color: #667eea; }
  .mode-btn.active { background: #667eea; border-color: #667eea; }
  #playBtn {
    margin-top: 20px;
    background: #667eea; border: none; color: #fff;
    font-size: 16px; padding: 13px 48px; border-radius: 8px;
    cursor: pointer; letter-spacing: 3px; text-transform: uppercase;
  }
  #playBtn:hover { background: #5568d6; }
  #goalMsg {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.88);
    color: #fff; font-size: 42px; font-weight: bold;
    padding: 18px 50px; border-radius: 12px;
    display: none; z-index: 20; letter-spacing: 4px;
    text-shadow: 0 0 24px rgba(255,200,0,0.9);
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="canvas" width="800" height="520"></canvas>
  <div id="overlay">
    <h1 id="overlayTitle">Ice Hockey</h1>
    <p class="sub" id="overlaySub">First to 5 goals wins</p>
    <div class="controls">
      <div class="ctrl">
        <h3 class="red">PLAYER 1</h3>
        <p>WASD — Move</p>
      </div>
      <div class="ctrl" id="p2ctrl">
        <h3 class="blue">PLAYER 2</h3>
        <p>Arrow Keys — Move</p>
      </div>
    </div>
    <div class="mode-btns">
      <button class="mode-btn active" id="twoPlayerBtn">2 Players</button>
      <button class="mode-btn" id="botBtn">vs Bot</button>
    </div>
    <button id="playBtn">PLAY</button>
  </div>
  <div id="goalMsg">GOAL!</div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 800, H = 520;

// Rink layout
const RX = 30, RY = 65, RW = 740, RH = 390;
const GOAL_DEPTH = 14, GOAL_H = 92;
const GOAL_Y1 = RY + RH/2 - GOAL_H/2;
const GOAL_Y2 = RY + RH/2 + GOAL_H/2;

// Constants
const PR = 20;        // player radius
const PUCK_R = 7;     // puck radius
const PLAYER_FRIC = 0.979;
const PUCK_FRIC = 0.990;
const PUCK_MAX = 30;
const STICK_LEN = 42;
const STICK_R = 3;
const WIN = 5;

let score = [0, 0];
let phase = 'menu'; // menu, playing, goal, over
let goalTimer = 0;
let gameMode = 'twoPlayer'; // 'twoPlayer' or 'vsBot'

function mkPlayer(x, y, color, keys, initAngle = 0) {
  return { x, y, vx: 0, vy: 0, color, keys, angle: initAngle, dx: Math.cos(initAngle), dy: Math.sin(initAngle), stun: 0 };
}

function lerpAngle(a, b, t) {
  let d = b - a;
  while (d > Math.PI) d -= Math.PI * 2;
  while (d < -Math.PI) d += Math.PI * 2;
  return a + d * t;
}

let p1, p2, puck;
let botKickoffOffset = 0;

function reset() {
  p1 = mkPlayer(RX + 160, RY + RH/2, '#e05050', { up:'w', dn:'s', lt:'a', rt:'d' }, 0);
  p2 = mkPlayer(RX + RW - 160, RY + RH/2, '#5090ee', { up:'ArrowUp', dn:'ArrowDown', lt:'ArrowLeft', rt:'ArrowRight' }, Math.PI);
  puck = { x: RX + RW/2, y: RY + RH/2, vx: 0, vy: 0 };
  // Random lateral offset so bot doesn't charge straight at kickoff
  botKickoffOffset = (Math.random() - 0.5) * 80;
}

const keys = {};
window.addEventListener('keydown', e => {
  if (!keys[e.key]) {
    keys[e.key] = true;
    if ([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
  }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

function getStick(p) {
  // Offset to player's right side: perpendicular is (dy, -dx)
  const offX = p.dy * PR * 0.7, offY = -p.dx * PR * 0.7;
  const sx = p.x + p.dx * PR * 0.4 + offX;
  const sy = p.y + p.dy * PR * 0.4 + offY;
  return { sx, sy, ex: sx + p.dx * STICK_LEN, ey: sy + p.dy * STICK_LEN };
}

function stickHitPuck(p) {
  const { sx, sy, ex, ey } = getStick(p);
  const segDx = ex - sx, segDy = ey - sy;

  const segLen2 = segDx*segDx + segDy*segDy;
  let t = ((puck.x - sx)*segDx + (puck.y - sy)*segDy) / segLen2;
  t = Math.max(0, Math.min(1, t));
  const cx = sx + t*segDx, cy = sy + t*segDy;
  const dx = puck.x - cx, dy = puck.y - cy;
  const dist = Math.hypot(dx, dy);
  const minDist = PUCK_R + STICK_R;
  if (dist < minDist && dist > 0) {
    const nx = dx/dist, ny = dy/dist;
    puck.x = cx + nx * minDist;
    puck.y = cy + ny * minDist;
    const relDot = (puck.vx - p.vx)*nx + (puck.vy - p.vy)*ny;
    if (relDot < 0) {
      puck.vx -= relDot * nx * 1.8;
      puck.vy -= relDot * ny * 1.8;
      puck.vx += p.vx * 0.4;
      puck.vy += p.vy * 0.4;
    }
  }
}

function movePlayer(p) {
  if (p.stun > 0) { p.stun--; return; }
  let mx = 0, my = 0;
  if (keys[p.keys.up]) my -= 1;
  if (keys[p.keys.dn]) my += 1;
  if (keys[p.keys.lt]) mx -= 1;
  if (keys[p.keys.rt]) mx += 1;
  if (mx !== 0 || my !== 0) {
    const len = Math.hypot(mx, my);
    mx /= len; my /= len;
    p.angle = lerpAngle(p.angle, Math.atan2(my, mx), 0.15);
    p.vx += mx * 0.12;
    p.vy += my * 0.12;
  }
  p.dx = Math.cos(p.angle);
  p.dy = Math.sin(p.angle);
  p.x += p.vx; p.y += p.vy;
  p.vx *= PLAYER_FRIC; p.vy *= PLAYER_FRIC;

  // Clamp to rink
  if (p.x - PR < RX)       { p.x = RX + PR;       p.vx = Math.abs(p.vx) * 0.5; }
  if (p.x + PR > RX + RW)  { p.x = RX + RW - PR;  p.vx = -Math.abs(p.vx) * 0.5; }
  if (p.y - PR < RY)       { p.y = RY + PR;        p.vy = Math.abs(p.vy) * 0.5; }
  if (p.y + PR > RY + RH)  { p.y = RY + RH - PR;  p.vy = -Math.abs(p.vy) * 0.5; }
}

function bodyCheck() {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const dist = Math.hypot(dx, dy);
  if (dist >= PR * 2) return;
  const nx = dx/dist, ny = dy/dist;
  const overlap = PR*2 - dist;
  p1.x -= nx * overlap/2; p1.y -= ny * overlap/2;
  p2.x += nx * overlap/2; p2.y += ny * overlap/2;

  const s1 = Math.hypot(p1.vx, p1.vy);
  const s2 = Math.hypot(p2.vx, p2.vy);

  // P1 checking P2
  if (s1 > 2.5 && (p1.vx*nx + p1.vy*ny) > 0) {
    p2.vx += nx * s1 * 0.9; p2.vy += ny * s1 * 0.9;
    p2.stun = 35;
    p1.vx *= 0.4; p1.vy *= 0.4;
  }
  // P2 checking P1
  if (s2 > 2.5 && (p2.vx*(-nx) + p2.vy*(-ny)) > 0) {
    p1.vx -= nx * s2 * 0.9; p1.vy -= ny * s2 * 0.9;
    p1.stun = 35;
    p2.vx *= 0.4; p2.vy *= 0.4;
  }
}

function updatePuck() {
  puck.x += puck.vx; puck.y += puck.vy;
  puck.vx *= PUCK_FRIC; puck.vy *= PUCK_FRIC;

  // Wall collisions — allow puck through goal openings
  if (puck.x - PUCK_R < RX) {
    if (puck.y < GOAL_Y1 || puck.y > GOAL_Y2) {
      puck.x = RX + PUCK_R; puck.vx = Math.abs(puck.vx) * 0.7;
    }
  }
  if (puck.x + PUCK_R > RX + RW) {
    if (puck.y < GOAL_Y1 || puck.y > GOAL_Y2) {
      puck.x = RX + RW - PUCK_R; puck.vx = -Math.abs(puck.vx) * 0.7;
    }
  }
  if (puck.y - PUCK_R < RY) { puck.y = RY + PUCK_R; puck.vy = Math.abs(puck.vy) * 0.7; }
  if (puck.y + PUCK_R > RY + RH) { puck.y = RY + RH - PUCK_R; puck.vy = -Math.abs(puck.vy) * 0.7; }

  // Goal back walls
  if (puck.y >= GOAL_Y1 && puck.y <= GOAL_Y2) {
    if (puck.x - PUCK_R < RX - GOAL_DEPTH) { puck.x = RX - GOAL_DEPTH + PUCK_R; puck.vx = Math.abs(puck.vx) * 0.5; }
    if (puck.x + PUCK_R > RX + RW + GOAL_DEPTH) { puck.x = RX + RW + GOAL_DEPTH - PUCK_R; puck.vx = -Math.abs(puck.vx) * 0.5; }
  }

  const pspd = Math.hypot(puck.vx, puck.vy);
  if (pspd > PUCK_MAX) { puck.vx = puck.vx/pspd * PUCK_MAX; puck.vy = puck.vy/pspd * PUCK_MAX; }

  // Body-puck collision
  for (const p of [p1, p2]) {
    const dx = puck.x - p.x, dy = puck.y - p.y;
    const dist = Math.hypot(dx, dy);
    if (dist < PR + PUCK_R && dist > 0) {
      const nx = dx/dist, ny = dy/dist;
      puck.x = p.x + nx * (PR + PUCK_R);
      puck.y = p.y + ny * (PR + PUCK_R);
      const dot = (puck.vx - p.vx)*nx + (puck.vy - p.vy)*ny;
      if (dot < 0) {
        puck.vx -= dot * nx;
        puck.vy -= dot * ny;
      }
    }
  }

  // Stick-puck collision
  stickHitPuck(p1);
  stickHitPuck(p2);
}

function checkGoal() {
  if (puck.y < GOAL_Y1 || puck.y > GOAL_Y2) return false;
  if (puck.x < RX - 4) { score[1]++; goal(); return true; }
  if (puck.x > RX + RW + 4) { score[0]++; goal(); return true; }
  return false;
}

function goal() {
  phase = 'goal';
  goalTimer = 130;
  const msg = document.getElementById('goalMsg');
  if (score[0] >= WIN || score[1] >= WIN) {
    msg.textContent = `Player ${score[0] >= WIN ? 1 : 2} Wins!`;
  } else {
    msg.textContent = 'GOAL!';
  }
  msg.style.display = 'block';
}

function updateBot() {
  const bot = p2;
  if (bot.stun > 0) { bot.stun--; return; }

  // Predict puck position a short time ahead
  const lookahead = 14;
  const tpx = Math.max(RX + PR, Math.min(RX + RW - PR, puck.x + puck.vx * lookahead));
  const tpy = Math.max(RY + PR, Math.min(RY + RH - PR, puck.y + puck.vy * lookahead));

  // If bot's stick is near puck, push toward P1's goal (left side)
  const { sx, sy, ex, ey } = getStick(bot);
  const nearPuck = Math.hypot(puck.x - bot.x, puck.y - bot.y) < PR + PUCK_R + STICK_LEN + 5;

  let tx, ty;
  if (nearPuck) {
    // Attack: aim at left goal
    tx = RX + 10;
    ty = RY + RH / 2;
  } else {
    // Chase predicted puck, with a lateral offset at kickoff (when puck is slow)
    const puckSpeed = Math.hypot(puck.vx, puck.vy);
    const offsetFade = Math.max(0, 1 - puckSpeed / 3);
    tx = tpx;
    ty = tpy + botKickoffOffset * offsetFade;
  }

  const ddx = tx - bot.x, ddy = ty - bot.y;
  const dist = Math.hypot(ddx, ddy);
  if (dist > 6) {
    const mx = ddx / dist, my = ddy / dist;
    bot.angle = lerpAngle(bot.angle, Math.atan2(my, mx), 0.12);
    bot.vx += mx * 0.12;
    bot.vy += my * 0.12;
  }
  bot.dx = Math.cos(bot.angle);
  bot.dy = Math.sin(bot.angle);
  bot.x += bot.vx; bot.y += bot.vy;
  bot.vx *= PLAYER_FRIC; bot.vy *= PLAYER_FRIC;

  if (bot.x - PR < RX)      { bot.x = RX + PR;      bot.vx =  Math.abs(bot.vx) * 0.5; }
  if (bot.x + PR > RX + RW) { bot.x = RX + RW - PR; bot.vx = -Math.abs(bot.vx) * 0.5; }
  if (bot.y - PR < RY)      { bot.y = RY + PR;       bot.vy =  Math.abs(bot.vy) * 0.5; }
  if (bot.y + PR > RY + RH) { bot.y = RY + RH - PR;  bot.vy = -Math.abs(bot.vy) * 0.5; }
}

function update() {
  if (phase !== 'playing') return;
  movePlayer(p1);
  if (gameMode === 'vsBot') updateBot();
  else movePlayer(p2);
  bodyCheck();
  updatePuck();
  checkGoal();
}

function tickGoal() {
  if (phase !== 'goal') return;
  goalTimer--;
  if (goalTimer > 0) return;
  document.getElementById('goalMsg').style.display = 'none';
  if (score[0] >= WIN || score[1] >= WIN) {
    phase = 'over';
    const winner = score[0] >= WIN ? 'Player 1' : (gameMode === 'vsBot' ? 'Bot' : 'Player 2');
    document.getElementById('overlayTitle').textContent = `${winner} Wins!`;
    document.getElementById('overlaySub').textContent = `${score[0]} – ${score[1]}`;
    document.getElementById('overlay').classList.remove('hidden');
  } else {
    reset();
    phase = 'playing';
  }
}

// --- Drawing ---

function drawRink() {
  // Ice surface
  ctx.fillStyle = '#c9e9f5';
  ctx.beginPath();
  ctx.roundRect(RX, RY, RW, RH, 22);
  ctx.fill();

  // Clip to rink for lines
  ctx.save();
  ctx.beginPath();
  ctx.roundRect(RX, RY, RW, RH, 22);
  ctx.clip();

  // Blue lines
  ctx.strokeStyle = '#2255cc';
  ctx.lineWidth = 7;
  [0.25, 0.75].forEach(t => {
    ctx.beginPath();
    ctx.moveTo(RX + RW*t, RY);
    ctx.lineTo(RX + RW*t, RY + RH);
    ctx.stroke();
  });

  // Center red line
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(RX + RW/2, RY);
  ctx.lineTo(RX + RW/2, RY + RH);
  ctx.stroke();

  // Center circle
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(RX + RW/2, RY + RH/2, 44, 0, Math.PI*2);
  ctx.stroke();
  ctx.fillStyle = '#cc2222';
  ctx.beginPath();
  ctx.arc(RX + RW/2, RY + RH/2, 4, 0, Math.PI*2);
  ctx.fill();

  // Goal creases
  ctx.fillStyle = 'rgba(80,130,220,0.25)';
  ctx.fillRect(RX, GOAL_Y1, 55, GOAL_H);
  ctx.fillStyle = 'rgba(80,130,220,0.25)';
  ctx.fillRect(RX + RW - 55, GOAL_Y1, 55, GOAL_H);

  ctx.restore();

  // Rink border (red)
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(RX, RY, RW, RH, 22);
  ctx.stroke();

  // Goals
  ctx.strokeStyle = '#cc2222';
  ctx.lineWidth = 3;
  // Left goal
  ctx.strokeRect(RX - GOAL_DEPTH, GOAL_Y1, GOAL_DEPTH, GOAL_H);
  ctx.fillStyle = 'rgba(200,50,50,0.15)';
  ctx.fillRect(RX - GOAL_DEPTH, GOAL_Y1, GOAL_DEPTH, GOAL_H);
  // Right goal
  ctx.strokeRect(RX + RW, GOAL_Y1, GOAL_DEPTH, GOAL_H);
  ctx.fillStyle = 'rgba(200,50,50,0.15)';
  ctx.fillRect(RX + RW, GOAL_Y1, GOAL_DEPTH, GOAL_H);
}

function drawPlayer(p) {
  if (p.stun > 0 && Math.floor(p.stun/4) % 2 === 1) return;

  const { sx, sy, ex, ey } = getStick(p);
  const faceAngle = Math.atan2(p.dy, p.dx);

  // Stick (draw behind player body)
  ctx.strokeStyle = '#5a2d0c';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(sx, sy);
  ctx.lineTo(ex, ey);
  ctx.stroke();
  ctx.lineCap = 'butt';

  // Jersey (body circle)
  ctx.fillStyle = p.color;
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR, 0, Math.PI*2);
  ctx.fill();
  // Jersey outline
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Helmet (dark rounded cap, top-down view)
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR * 0.6, 0, Math.PI*2);
  ctx.fill();

  // Helmet color stripe (team color accent on helmet)
  ctx.strokeStyle = p.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR * 0.6, faceAngle - 1.1, faceAngle + 1.1);
  ctx.stroke();

  // Visor (light reflective arc on front of helmet)
  ctx.strokeStyle = 'rgba(200,230,255,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(p.x, p.y, PR * 0.6, faceAngle - 0.6, faceAngle + 0.6);
  ctx.stroke();
}

function drawPuck() {
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(puck.x, puck.y, PUCK_R, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawHUD() {
  // Background strip
  ctx.fillStyle = '#0d0d22';
  ctx.fillRect(0, 0, W, RY - 2);

  // P1 score
  ctx.fillStyle = '#e05050';
  ctx.font = 'bold 38px Segoe UI';
  ctx.textAlign = 'right';
  ctx.fillText(score[0], W/2 - 22, 50);

  // Dash
  ctx.fillStyle = '#555';
  ctx.textAlign = 'center';
  ctx.font = 'bold 28px Segoe UI';
  ctx.fillText('–', W/2, 48);

  // P2 score
  ctx.fillStyle = '#5090ee';
  ctx.textAlign = 'left';
  ctx.font = 'bold 38px Segoe UI';
  ctx.fillText(score[1], W/2 + 22, 50);

  // Labels
  ctx.font = '12px Segoe UI';
  ctx.fillStyle = '#e05050';
  ctx.textAlign = 'center';
  ctx.fillText('P1', RX + 80, RY - 8);
  ctx.fillStyle = '#5090ee';
  ctx.fillText('P2', RX + RW - 80, RY - 8);
}

function draw() {
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, W, H);
  drawRink();
  drawPlayer(p1);
  drawPlayer(p2);
  drawPuck();
  drawHUD();
}

function loop() {
  update();
  tickGoal();
  draw();
  requestAnimationFrame(loop);
}

function startGame(mode) {
  gameMode = mode;
  score = [0, 0];
  reset();
  phase = 'playing';
  document.getElementById('overlayTitle').textContent = 'Ice Hockey';
  document.getElementById('overlaySub').textContent = 'First to 5 goals wins';
  document.getElementById('p2ctrl').style.display = mode === 'vsBot' ? 'none' : '';
  document.getElementById('overlay').classList.add('hidden');
}

document.getElementById('twoPlayerBtn').addEventListener('click', () => {
  gameMode = 'twoPlayer';
  document.getElementById('twoPlayerBtn').classList.add('active');
  document.getElementById('botBtn').classList.remove('active');
});

document.getElementById('botBtn').addEventListener('click', () => {
  gameMode = 'vsBot';
  document.getElementById('botBtn').classList.add('active');
  document.getElementById('twoPlayerBtn').classList.remove('active');
});

document.getElementById('playBtn').addEventListener('click', () => {
  startGame(gameMode);
});

reset();
loop();
</script>
</body>
</html>
