<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Asteroid Miner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 560;

// ── Audio ──
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}
function playTone(freq, freq2, dur, vol, wave) {
  const a = getAudio(), t = a.currentTime;
  const o = a.createOscillator(), g = a.createGain();
  o.type = wave || 'sine';
  o.frequency.setValueAtTime(freq, t);
  o.frequency.exponentialRampToValueAtTime(freq2, t + dur);
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.connect(g); g.connect(a.destination);
  o.start(t); o.stop(t + dur);
}
function sfxLaser() {
  const a = getAudio(), t = a.currentTime;
  // Soft chime-like pew
  const o = a.createOscillator(), g = a.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(660, t);
  o.frequency.exponentialRampToValueAtTime(330, t + 0.15);
  g.gain.setValueAtTime(0.04, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
  o.connect(g); g.connect(a.destination);
  o.start(t); o.stop(t + 0.15);
  // Gentle harmonic overtone
  const o2 = a.createOscillator(), g2 = a.createGain();
  o2.type = 'sine';
  o2.frequency.setValueAtTime(990, t);
  o2.frequency.exponentialRampToValueAtTime(495, t + 0.1);
  g2.gain.setValueAtTime(0.015, t);
  g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  o2.connect(g2); g2.connect(a.destination);
  o2.start(t); o2.stop(t + 0.1);
}

// Thruster hum — only exists while thrusting
let thrusterNode = null, thrusterGain = null, thrusterIsOn = false;
function setThrusterOn(on) {
  if (on === thrusterIsOn) return;
  thrusterIsOn = on;
  const a = getAudio();
  if (on) {
    thrusterNode = a.createOscillator();
    thrusterGain = a.createGain();
    thrusterNode.type = 'sine';
    thrusterNode.frequency.value = 80;
    thrusterGain.gain.value = 0.025;
    thrusterNode.connect(thrusterGain);
    thrusterGain.connect(a.destination);
    thrusterNode.start();
  } else if (thrusterNode) {
    try { thrusterNode.stop(); } catch(e) {}
    thrusterNode.disconnect(); thrusterGain.disconnect();
    thrusterNode = null; thrusterGain = null;
  }
}
function sfxHit() { playTone(200, 80, 0.08, 0.15, 'sawtooth'); }
function sfxBreak() { playTone(150, 40, 0.2, 0.2, 'sawtooth'); }
function sfxOre() { playTone(600, 900, 0.12, 0.12); }
function sfxDamage() { playTone(100, 50, 0.15, 0.25, 'square'); }
function sfxUpgrade() { playTone(400, 800, 0.3, 0.15); }
function sfxShield() { playTone(500, 300, 0.1, 0.15); }
function sfxAlienShoot() { playTone(900, 400, 0.12, 0.08, 'sawtooth'); }
function sfxAlienHit() { playTone(250, 100, 0.15, 0.12, 'square'); }
function sfxDeath() {
  const a = getAudio(), t = a.currentTime;
  [0, 0.1, 0.2, 0.35].forEach((d, i) => {
    const o = a.createOscillator(), g = a.createGain();
    o.type = 'sawtooth';
    o.frequency.setValueAtTime(200 - i * 40, t + d);
    o.frequency.exponentialRampToValueAtTime(30, t + d + 0.2);
    g.gain.setValueAtTime(0.15, t + d);
    g.gain.exponentialRampToValueAtTime(0.001, t + d + 0.25);
    o.connect(g); g.connect(a.destination);
    o.start(t + d); o.stop(t + d + 0.25);
  });
}

// ── Music ──
let musicPlaying = false;
let musicNodes = [];
function startMusic() {
  if (musicPlaying) return;
  const a = getAudio();
  musicPlaying = true;
  const master = a.createGain();
  master.gain.value = 0.045;
  master.connect(a.destination);
  // Pad layer — slow evolving chords
  const padNotes = [110, 164.81, 220, 329.63]; // A2, E3, A3, E4
  padNotes.forEach(freq => {
    const o = a.createOscillator(), g = a.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.value = 0.3;
    o.connect(g); g.connect(master);
    o.start();
    musicNodes.push(o, g);
  });
  // Sub bass drone
  const sub = a.createOscillator(), sg = a.createGain();
  sub.type = 'sine'; sub.frequency.value = 55; // A1
  sg.gain.value = 0.4;
  sub.connect(sg); sg.connect(master);
  sub.start();
  musicNodes.push(sub, sg);
  // Slow LFO to modulate pad volume for movement
  const lfo = a.createOscillator(), lfoG = a.createGain();
  lfo.type = 'sine'; lfo.frequency.value = 0.08;
  lfoG.gain.value = 0.015;
  lfo.connect(lfoG); lfoG.connect(master.gain);
  lfo.start();
  musicNodes.push(lfo, lfoG);
  // High shimmer
  const shimmer = a.createOscillator(), shG = a.createGain();
  shimmer.type = 'sine'; shimmer.frequency.value = 659.25; // E5
  shG.gain.value = 0.06;
  shimmer.connect(shG); shG.connect(master);
  shimmer.start();
  musicNodes.push(shimmer, shG);
  // Second LFO for shimmer tremolo
  const lfo2 = a.createOscillator(), lfo2G = a.createGain();
  lfo2.type = 'sine'; lfo2.frequency.value = 0.15;
  lfo2G.gain.value = 0.04;
  lfo2.connect(lfo2G); lfo2G.connect(shG.gain);
  lfo2.start();
  musicNodes.push(lfo2, lfo2G, master);
}
function stopMusic() {
  musicNodes.forEach(n => { try { if (n.stop) n.stop(); n.disconnect(); } catch(e){} });
  musicNodes = [];
  musicPlaying = false;
}

// ── Input ──
const keys = {};
const prevKeys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });
function keyPressed(code) { return keys[code] && !prevKeys[code]; }
function copyKeys() { for (const k in keys) prevKeys[k] = keys[k]; }

// ── Constants ──
const CHUNK_SIZE = 500;
const SPAWN_RADIUS = 3;
const DESPAWN_DIST = CHUNK_SIZE * (SPAWN_RADIUS + 2);
const LASER_SPEED = 10;
const LASER_LIFE = 50;
const BASE_LASER_CD = 18;
const SHIP_RADIUS = 12;
const STATION_RADIUS = 35;
const ORE_LIFE = 600;
const INVULN_TIME = 60;
const BASE_ORE_RANGE = 22;
const SHIELD_REGEN_DELAY = 300; // frames (5 sec)

const UPGRADES = {
  hull:   { costs: [10, 25, 50], label: 'Hull',   desc: 'Max HP' },
  engine: { costs: [10, 25, 50], label: 'Engine', desc: 'Thrust' },
  laser:  { costs: [15, 30, 60], label: 'Laser',  desc: 'Damage' },
  rate:   { costs: [10, 25, 50], label: 'Fire Rate', desc: 'Shoot faster' },
  shield: { costs: [15, 35, 70], label: 'Shield', desc: 'Regen shield' },
  magnet: { costs: [10, 20, 40], label: 'Magnet', desc: 'Ore range' },
};

const ORE_TYPES = [
  { name: 'Iron',    color: '#888', dropColor: '#aaa', value: 1 },
  { name: 'Gold',    color: '#da2', dropColor: '#fe4', value: 3 },
  { name: 'Crystal', color: '#4de', dropColor: '#6ff', value: 5 },
];

// ── Game State ──
let state = 'menu'; // menu, playing, gameover
let mode = '1P';
let ships = [];
let lasers, asteroids, oreDrops, particles, populatedChunks;
let alienBases, alienProjectiles, botShips;
let stations; // array of { x, y, hp, maxHp, destroyed, owner (ship num) }
let botColorIdx = 0;
let stationAngle = 0;
let screenShake = 0;
let hoverMode = false, hoverStart = false;

// Parallax stars
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({
    x: Math.random() * 1600 - 800, y: Math.random() * 1200 - 600,
    size: Math.random() * 1.5 + 0.5,
    layer: Math.random() < 0.3 ? 0.3 : Math.random() < 0.6 ? 0.5 : 0.7,
    brightness: 0.3 + Math.random() * 0.7,
  });
}

function createShip(x, y, color, cockpitColor, num) {
  return {
    x, y, angle: -Math.PI / 2, vx: 0, vy: 0,
    hp: 5, maxHp: 5, ore: 0, money: 0,
    shield: 0, maxShield: 0, shieldTimer: 0,
    thrustPower: 0.12, laserDamage: 1, laserCooldown: 0,
    invuln: 0, alive: true,
    upgrades: { hull: 0, engine: 0, laser: 0, rate: 0, shield: 0, magnet: 0 },
    thrusting: false,
    color, cockpitColor, num,
    inShop: false, shopSelection: 0, shopOpenCd: 0,
  };
}

const BOT_NAMES = ['Cipher','Atlas','Echo','Zenith','Orion','Lynx','Helix','Sable','Flux','Kestrel','Sigma','Nyx','Ion','Frost','Halo','Nova','Viper','Raptor','Blaze','Ghost','Razor','Comet','Jinx','Havoc','Talon','Scorch','Drift','Vector','Pulse','Onyx','Flint','Striker','Phantom','Zero','Riot'];
const BOT_COLORS = [
  { color: '#f80', cockpit: '#fda' },
  { color: '#c4f', cockpit: '#eaf' },
  { color: '#ff4', cockpit: '#ffa' },
  { color: '#f44', cockpit: '#faa' },
  { color: '#4ff', cockpit: '#aff' },
  { color: '#f4a', cockpit: '#fca' },
  { color: '#8f4', cockpit: '#bfa' },
  { color: '#48f', cockpit: '#8af' },
];

function createBotShip(base) {
  const ci = botColorIdx++ % BOT_COLORS.length;
  const bot = {
    x: base.x, y: base.y, angle: Math.random() * Math.PI * 2,
    vx: 0, vy: 0, hp: 5, maxHp: 5, ore: 0, money: 0,
    shield: 0, maxShield: 0, shieldTimer: 0,
    thrustPower: 0.12, laserDamage: 1, laserCooldown: 0,
    invuln: 60, alive: true,
    upgrades: { hull: 0, engine: 0, laser: 0, rate: 0, shield: 0, magnet: 0 },
    thrusting: false,
    color: BOT_COLORS[ci].color, cockpitColor: BOT_COLORS[ci].cockpit,
    name: BOT_NAMES[ci % BOT_NAMES.length],
    homeBase: base, state: 'mining',
    targetAst: null, targetEnemy: null, respawnTimer: 0,
    num: -(ci + 1), isBot: true, grudge: 0,
  };
  base.botShip = bot;
  return bot;
}

function botSteer(bot, tx, ty, shouldThrust) {
  const desired = Math.atan2(ty - bot.y, tx - bot.x);
  let diff = desired - bot.angle;
  while (diff > Math.PI) diff -= Math.PI * 2;
  while (diff < -Math.PI) diff += Math.PI * 2;
  const turnSpd = 0.04;
  if (Math.abs(diff) < turnSpd) bot.angle = desired;
  else if (diff > 0) bot.angle += turnSpd;
  else bot.angle -= turnSpd;
  if (shouldThrust && Math.abs(diff) < Math.PI / 2.5) {
    bot.vx += Math.cos(bot.angle) * bot.thrustPower;
    bot.vy += Math.sin(bot.angle) * bot.thrustPower;
    bot.thrusting = true;
  }
  if (!bot.thrusting) { bot.vx *= 0.99; bot.vy *= 0.99; }
}

function botTryShoot(bot) {
  if (bot.laserCooldown > 0) return;
  const cd = Math.max(8, BASE_LASER_CD - bot.upgrades.rate * 3);
  const nx = bot.x + Math.cos(bot.angle) * 16;
  const ny = bot.y + Math.sin(bot.angle) * 16;
  lasers.push({
    x: nx, y: ny,
    vx: Math.cos(bot.angle) * LASER_SPEED + bot.vx * 0.3,
    vy: Math.sin(bot.angle) * LASER_SPEED + bot.vy * 0.3,
    life: LASER_LIFE, owner: -1, damage: bot.laserDamage,
    color: bot.color, isBot: true, botRef: bot,
  });
  bot.laserCooldown = cd;
}

function botAutoUpgrade(bot) {
  const totalUp = Object.values(bot.upgrades).reduce((a, v) => a + v, 0);
  // Early: engine, hull, magnet for mining. Later: laser, rate, shield for combat.
  const priority = totalUp < 3
    ? ['engine', 'hull', 'magnet', 'laser', 'rate', 'shield']
    : ['laser', 'rate', 'hull', 'shield', 'engine', 'magnet'];
  for (const key of priority) {
    const level = bot.upgrades[key];
    if (level < 3) {
      const cost = UPGRADES[key].costs[level];
      if (bot.money >= cost) {
        bot.money -= cost;
        bot.upgrades[key]++;
        if (key === 'hull') { bot.maxHp = 5 + bot.upgrades.hull * 2; bot.hp = bot.maxHp; }
        if (key === 'engine') bot.thrustPower = 0.12 + bot.upgrades.engine * 0.02;
        if (key === 'laser') bot.laserDamage = 1 + Math.floor(bot.upgrades.laser * 0.5);
        if (key === 'shield') { bot.maxShield = bot.upgrades.shield; bot.shield = bot.maxShield; }
        return;
      }
    }
  }
}

function damageBotShip(bot, dmg, fromX, fromY, fromPlayer) {
  if (bot.shield >= 1) {
    bot.shield = Math.max(0, bot.shield - dmg);
    bot.shieldTimer = 0;
    spawnParticles(bot.x, bot.y, '#4df', 6, 2);
    if (fromPlayer) bot.grudge += dmg;
    return;
  }
  bot.hp -= dmg;
  bot.invuln = INVULN_TIME;
  bot.shieldTimer = 0;
  if (fromPlayer) bot.grudge += dmg * 2;
  const dist = Math.hypot(bot.x - fromX, bot.y - fromY);
  if (dist > 0) { bot.vx = ((bot.x - fromX) / dist) * 3; bot.vy = ((bot.y - fromY) / dist) * 3; }
  spawnParticles(bot.x, bot.y, bot.color, 8, 2);
  if (bot.hp <= 0) {
    spawnParticles(bot.x, bot.y, '#f80', 20, 4);
    spawnParticles(bot.x, bot.y, bot.color, 15, 3);
    sfxDeath();
    bot.alive = false;
    // Drop some ore on death
    const dropCount = Math.min(5, Math.floor(bot.ore / 2));
    for (let k = 0; k < dropCount; k++) {
      oreDrops.push({
        x: bot.x + (Math.random() - 0.5) * 20, y: bot.y + (Math.random() - 0.5) * 20,
        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
        type: 1, value: 2, color: '#fe4', life: 500
      });
    }
    bot.ore = 0;
    bot.respawnTimer = 300;
    // Killed by player — respawn angry
    if (fromPlayer) bot.grudge = 10;
  }
}

function updateBotShip(bot) {
  if (!bot.alive) {
    // Respawn at home base if it still exists
    if (bot.homeBase && alienBases.includes(bot.homeBase)) {
      bot.respawnTimer--;
      if (bot.respawnTimer <= 0) {
        bot.alive = true;
        bot.x = bot.homeBase.x; bot.y = bot.homeBase.y;
        bot.vx = 0; bot.vy = 0;
        bot.hp = bot.maxHp; bot.shield = bot.maxShield;
        bot.shieldTimer = 0; bot.invuln = 120;
        bot.state = bot.grudge >= 5 ? 'revenge' : 'mining';
        bot.targetAst = null; bot.targetEnemy = null;
      }
    }
    return;
  }
  if (bot.invuln > 0) bot.invuln--;
  if (bot.laserCooldown > 0) bot.laserCooldown--;
  // Shield regen
  if (bot.maxShield > 0) {
    bot.shieldTimer++;
    if (bot.shieldTimer >= SHIELD_REGEN_DELAY && bot.shield < bot.maxShield)
      bot.shield = Math.min(bot.maxShield, bot.shield + 0.02);
  }

  const hpPct = bot.hp / bot.maxHp;
  const hasBase = bot.homeBase && alienBases.includes(bot.homeBase);
  const totalUpgrades = Object.values(bot.upgrades).reduce((a, v) => a + v, 0);

  // Early game: passive (mine & upgrade). Later: aggressive.
  // Only pick fights if upgraded enough, or if holding a grudge
  const aggressive = totalUpgrades >= 3 || bot.grudge >= 2;
  const detectRange = aggressive ? 250 : 100;

  // Find nearest enemy (player or other bot)
  let nearestEnemy = null, enemyDist = detectRange;
  for (const s of ships) {
    if (!s.alive) continue;
    const d = Math.hypot(s.x - bot.x, s.y - bot.y);
    if (d < enemyDist) { enemyDist = d; nearestEnemy = s; }
  }
  for (const other of botShips) {
    if (!other.alive || other === bot) continue;
    const d = Math.hypot(other.x - bot.x, other.y - bot.y);
    if (d < enemyDist) { enemyDist = d; nearestEnemy = other; }
  }

  // Grudge decays slowly
  if (bot.grudge > 0) bot.grudge -= 0.002;

  // State transitions
  if (hpPct < 0.35 && hasBase && bot.state !== 'revenge') {
    bot.state = 'returning'; bot.targetEnemy = null;
  } else if (bot.grudge >= 5 && bot.state !== 'returning' && stations.some(st => !st.destroyed)) {
    bot.state = 'revenge'; bot.targetEnemy = null;
  } else if (bot.state !== 'revenge') {
    if (nearestEnemy && bot.state !== 'returning') {
      bot.state = 'fighting'; bot.targetEnemy = nearestEnemy;
    } else if (bot.state === 'fighting' && !nearestEnemy) {
      bot.state = 'mining'; bot.targetEnemy = null;
    }
  }
  // Revenge ends when grudge runs out or station destroyed
  if (bot.state === 'revenge' && (bot.grudge < 1 || stations.every(st => st.destroyed))) {
    bot.state = 'mining'; bot.grudge = 0;
  }
  // Return to upgrade if enough ore (check in mining OR fighting states)
  if ((bot.state === 'mining' || bot.state === 'fighting') && hasBase) {
    const upKeys = Object.keys(UPGRADES);
    for (const key of upKeys) {
      const level = bot.upgrades[key];
      if (level < 3 && (bot.ore + bot.money) >= UPGRADES[key].costs[level]) {
        bot.state = 'returning'; bot.targetEnemy = null; break;
      }
    }
  }

  bot.thrusting = false;

  if (bot.state === 'mining') {
    // Find asteroid to mine
    if (!bot.targetAst || bot.targetAst.hp <= 0 || !asteroids.includes(bot.targetAst)) {
      bot.targetAst = null;
      let bestD = 600;
      for (const a of asteroids) {
        const d = Math.hypot(a.x - bot.x, a.y - bot.y);
        if (d < bestD) { bestD = d; bot.targetAst = a; }
      }
    }
    if (bot.targetAst) {
      const d = Math.hypot(bot.targetAst.x - bot.x, bot.targetAst.y - bot.y);
      botSteer(bot, bot.targetAst.x, bot.targetAst.y, d > 100);
      if (d < 200) botTryShoot(bot);
    } else {
      // Roam
      botSteer(bot, bot.x + Math.cos(bot.angle) * 200, bot.y + Math.sin(bot.angle) * 200, true);
    }
  } else if (bot.state === 'returning') {
    if (hasBase) {
      const d = Math.hypot(bot.homeBase.x - bot.x, bot.homeBase.y - bot.y);
      botSteer(bot, bot.homeBase.x, bot.homeBase.y, d > 60);
      // Brake when close so bot doesn't orbit
      if (d < 80) { bot.vx *= 0.92; bot.vy *= 0.92; }
      if (d < 50) {
        bot.hp = Math.min(bot.maxHp, bot.hp + 0.15);
        bot.shield = Math.min(bot.maxShield, bot.shield + 0.05);
        if (bot.ore > 0) { bot.money += bot.ore; bot.ore = 0; }
        if (bot.hp >= bot.maxHp) { botAutoUpgrade(bot); bot.state = 'mining'; bot.targetAst = null; }
      }
    } else { bot.state = 'mining'; }
  } else if (bot.state === 'fighting') {
    const e = bot.targetEnemy;
    if (e && ((e.alive !== undefined && e.alive) || (e.hp > 0))) {
      const d = Math.hypot(e.x - bot.x, e.y - bot.y);
      if (d > 400) { bot.state = 'mining'; bot.targetEnemy = null; }
      else { botSteer(bot, e.x, e.y, d > 80); botTryShoot(bot); }
    } else { bot.state = 'mining'; bot.targetEnemy = null; }
  } else if (bot.state === 'revenge') {
    // Head to nearest player station and attack it
    let tgt = null, tgtD = Infinity;
    for (const st of stations) {
      if (st.destroyed) continue;
      const dd = Math.hypot(bot.x - st.x, bot.y - st.y);
      if (dd < tgtD) { tgtD = dd; tgt = st; }
    }
    if (tgt) {
      botSteer(bot, tgt.x, tgt.y, tgtD > 60);
      if (tgtD < 200) botTryShoot(bot);
    }
    // Also fight any player in the way
    if (nearestEnemy && nearestEnemy.num > 0 && enemyDist < 150) {
      botSteer(bot, nearestEnemy.x, nearestEnemy.y, true);
      botTryShoot(bot);
    }
  }

  // Apply velocity
  const maxSpd = 4 + bot.upgrades.engine * 0.5;
  const spd = Math.hypot(bot.vx, bot.vy);
  if (spd > maxSpd) { bot.vx = (bot.vx / spd) * maxSpd; bot.vy = (bot.vy / spd) * maxSpd; }
  bot.x += bot.vx; bot.y += bot.vy;

  if (bot.thrusting) {
    spawnParticles(bot.x - Math.cos(bot.angle) * 14, bot.y - Math.sin(bot.angle) * 14, '#f80', 1, 1);
  }
}

function initGame() {
  ships = [];
  stations = [];
  if (mode === '1P') {
    const st = { x: 0, y: 0, hp: 30, maxHp: 30, destroyed: false, owner: 1, color: '#8af' };
    stations.push(st);
    const s1 = createShip(-30, -80, '#4f8', '#aff', 1);
    s1.station = st;
    ships.push(s1);
  } else {
    const st1 = { x: -400, y: 0, hp: 30, maxHp: 30, destroyed: false, owner: 1, color: '#4f8' };
    const st2 = { x: 400, y: 0, hp: 30, maxHp: 30, destroyed: false, owner: 2, color: '#f84' };
    stations.push(st1, st2);
    const s1 = createShip(st1.x - 30, st1.y - 80, '#4f8', '#aff', 1);
    s1.station = st1;
    ships.push(s1);
    const s2 = createShip(st2.x + 30, st2.y - 80, '#f84', '#ffa', 2);
    s2.station = st2;
    ships.push(s2);
  }
  lasers = []; asteroids = []; oreDrops = []; particles = [];
  alienBases = []; alienProjectiles = []; botShips = [];
  botColorIdx = 0;
  populatedChunks = new Set();
  state = 'playing';
  spawnChunksFor(ships[0]);
  startMusic();
}

// ── Asteroids ──
function genVerts(radius) {
  const n = 7 + Math.floor(Math.random() * 5), v = [];
  for (let i = 0; i < n; i++) {
    const a = (i / n) * Math.PI * 2;
    v.push({ x: Math.cos(a) * radius * (0.7 + Math.random() * 0.5), y: Math.sin(a) * radius * (0.7 + Math.random() * 0.5) });
  }
  return v;
}

function spawnAsteroid(x, y, size, type) {
  const r = { small: 15, medium: 30, large: 50 }[size];
  const hp = { small: 1, medium: 3, large: 6 }[size];
  const spd = 0.2 + Math.random() * 0.4;
  const a = Math.random() * Math.PI * 2;
  asteroids.push({ x, y, vx: Math.cos(a) * spd, vy: Math.sin(a) * spd, radius: r, size, type, hp, maxHp: hp, rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.02, verts: genVerts(r) });
}

function chunkKey(cx, cy) { return cx + ',' + cy; }

function spawnChunksFor(s) {
  const pcx = Math.floor(s.x / CHUNK_SIZE), pcy = Math.floor(s.y / CHUNK_SIZE);
  for (let dx = -SPAWN_RADIUS; dx <= SPAWN_RADIUS; dx++) {
    for (let dy = -SPAWN_RADIUS; dy <= SPAWN_RADIUS; dy++) {
      const cx = pcx + dx, cy = pcy + dy, key = chunkKey(cx, cy);
      if (populatedChunks.has(key)) continue;
      populatedChunks.add(key);
      if (cx === 0 && cy === 0) continue;
      const dist = Math.hypot(cx, cy);
      const count = 3 + Math.floor(Math.random() * 4 + dist * 0.5);
      for (let i = 0; i < count; i++) {
        const ax = cx * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
        const ay = cy * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
        let size, sizeR = Math.random();
        if (dist < 2) size = sizeR < 0.6 ? 'small' : 'medium';
        else if (dist < 4) size = sizeR < 0.3 ? 'small' : sizeR < 0.7 ? 'medium' : 'large';
        else size = sizeR < 0.15 ? 'small' : sizeR < 0.5 ? 'medium' : 'large';
        let type, tR = Math.random();
        const gc = Math.min(0.3, dist * 0.04), cc = Math.min(0.15, dist * 0.02);
        if (tR < cc) type = 2; else if (tR < cc + gc) type = 1; else type = 0;
        spawnAsteroid(ax, ay, size, type);
      }
      // Alien base: chance to spawn in nearby chunks — each gets one bot miner (max 10)
      if (dist >= 2 && Math.random() < 0.15 && botShips.length < 10) {
        const bx = cx * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
        const by = cy * CHUNK_SIZE + Math.random() * CHUNK_SIZE;
        const base = {
          x: bx, y: by, hp: 8 + Math.floor(dist), maxHp: 8 + Math.floor(dist),
          shootTimer: 0, shootCd: 80 + Math.floor(Math.random() * 40),
          range: 300 + dist * 20, radius: 20, angle: Math.random() * Math.PI * 2,
          flashTimer: 0
        };
        alienBases.push(base);
        botShips.push(createBotShip(base));
      }
    }
  }
}

function cleanupFar() {
  // Keep asteroids near any living ship
  for (let i = asteroids.length - 1; i >= 0; i--) {
    const a = asteroids[i];
    let near = false;
    for (const s of ships) { if (s.alive && Math.hypot(a.x - s.x, a.y - s.y) < DESPAWN_DIST) { near = true; break; } }
    if (!near) asteroids.splice(i, 1);
  }
  // Cleanup far alien bases and projectiles
  for (let i = alienBases.length - 1; i >= 0; i--) {
    const b = alienBases[i];
    let near = false;
    for (const s of ships) { if (s.alive && Math.hypot(b.x - s.x, b.y - s.y) < DESPAWN_DIST) { near = true; break; } }
    if (!near) alienBases.splice(i, 1);
  }
  for (let i = alienProjectiles.length - 1; i >= 0; i--) {
    const p = alienProjectiles[i];
    p.life--;
    if (p.life <= 0) { alienProjectiles.splice(i, 1); continue; }
    let near = false;
    for (const s of ships) { if (s.alive && Math.hypot(p.x - s.x, p.y - s.y) < DESPAWN_DIST) { near = true; break; } }
    if (!near) alienProjectiles.splice(i, 1);
  }
  // Cleanup bot ships: remove if home base was cleaned up
  for (let i = botShips.length - 1; i >= 0; i--) {
    const b = botShips[i];
    if (b.homeBase && !alienBases.includes(b.homeBase)) {
      botShips.splice(i, 1); continue;
    }
    if (!b.alive && !b.homeBase) { botShips.splice(i, 1); continue; }
    let near = false;
    for (const s of ships) { if (s.alive && Math.hypot(b.x - s.x, b.y - s.y) < DESPAWN_DIST) { near = true; break; } }
    if (b.homeBase && Math.hypot(b.x - b.homeBase.x, b.y - b.homeBase.y) < DESPAWN_DIST) near = true;
    if (!near && b.alive) { botShips.splice(i, 1); }
  }
}

// ── Particles ──
function spawnParticles(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2, s = (speed || 2) * (0.5 + Math.random());
    particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 15 + Math.random() * 20, maxLife: 35, color, size: 1 + Math.random() * 2 });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vx *= 0.97; p.vy *= 0.97; p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// ── Ship Update ──
function getShipKeys(num) {
  if (num === 1) return { left: 'KeyA', right: 'KeyD', up: 'KeyW', down: 'KeyS', shoot: 'Space', dock: 'KeyE' };
  return { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', down: 'ArrowDown', shoot: 'Enter', dock: 'ShiftRight' };
}

function updateShip(s) {
  if (!s.alive) return;
  if (s.inShop) return;
  const k = getShipKeys(s.num);
  const turnSpeed = 0.05;

  if (keys[k.left]) s.angle -= turnSpeed;
  if (keys[k.right]) s.angle += turnSpeed;

  s.thrusting = false;
  if (keys[k.up]) {
    s.vx += Math.cos(s.angle) * s.thrustPower;
    s.vy += Math.sin(s.angle) * s.thrustPower;
    s.thrusting = true;
  }
  if (keys[k.down]) { s.vx *= 0.97; s.vy *= 0.97; }

  const maxSpd = 4 + s.upgrades.engine * 0.5;
  const spd = Math.hypot(s.vx, s.vy);
  if (spd > maxSpd) { s.vx = (s.vx / spd) * maxSpd; s.vy = (s.vy / spd) * maxSpd; }

  s.x += s.vx; s.y += s.vy;
  if (s.invuln > 0) s.invuln--;
  if (s.laserCooldown > 0) s.laserCooldown--;

  // Shield regen
  if (s.maxShield > 0) {
    s.shieldTimer++;
    if (s.shieldTimer >= SHIELD_REGEN_DELAY && s.shield < s.maxShield) {
      s.shield = Math.min(s.maxShield, s.shield + 0.02);
    }
  }

  // Shoot
  const cd = Math.max(8, BASE_LASER_CD - s.upgrades.rate * 3);
  if (keys[k.shoot] && s.laserCooldown <= 0) {
    const nx = s.x + Math.cos(s.angle) * 16, ny = s.y + Math.sin(s.angle) * 16;
    lasers.push({ x: nx, y: ny, vx: Math.cos(s.angle) * LASER_SPEED + s.vx * 0.3, vy: Math.sin(s.angle) * LASER_SPEED + s.vy * 0.3, life: LASER_LIFE, owner: s.num, damage: s.laserDamage, color: s.num === 1 ? '#f44' : '#fa4' });
    s.laserCooldown = cd;
    sfxLaser();
  }

  // Dock
  if (!s.station.destroyed && keyPressed(k.dock) && Math.hypot(s.x - s.station.x, s.y - s.station.y) < STATION_RADIUS + 40) {
    if (s.ore > 0) { s.money += s.ore; s.ore = 0; }
    s.inShop = true;
    s.shopSelection = 0;
    s.shopOpenCd = 2;
  }

  // Thruster particles
  if (s.thrusting) {
    spawnParticles(s.x - Math.cos(s.angle) * 14, s.y - Math.sin(s.angle) * 14, s.num === 1 ? '#f80' : '#f40', 1, 1);
  }
}

function damageShip(s, dmg, fromX, fromY) {
  if (s.inShop) return;
  // Shield absorbs first
  if (s.shield >= 1) {
    s.shield = Math.max(0, s.shield - dmg);
    s.shieldTimer = 0;
    spawnParticles(s.x, s.y, '#4df', 6, 2);
    sfxShield();
    return;
  }

  s.hp -= dmg;
  s.invuln = INVULN_TIME;
  s.shieldTimer = 0;
  screenShake = 8;

  const dist = Math.hypot(s.x - fromX, s.y - fromY);
  if (dist > 0) { s.vx = ((s.x - fromX) / dist) * 3; s.vy = ((s.y - fromY) / dist) * 3; }
  spawnParticles(s.x, s.y, '#f44', 8, 2);
  sfxDamage();

  if (s.hp <= 0) {
    spawnParticles(s.x, s.y, '#f80', 30, 4);
    spawnParticles(s.x, s.y, '#ff0', 20, 3);
    sfxDeath();
    if (s.station.destroyed) {
      // No respawn — game over
      s.alive = false;
      // Check if all player ships dead
      if (ships.every(sh => !sh.alive)) state = 'gameover';
    } else {
      // Respawn at station, lose all ore
      s.x = s.station.x; s.y = s.station.y - 80;
      s.vx = 0; s.vy = 0;
      s.angle = -Math.PI / 2;
      s.hp = s.maxHp;
      s.shield = s.maxShield;
      s.shieldTimer = 0;
      s.ore = 0;
      s.invuln = 120;
      s.laserCooldown = 0;
    }
  }
}

// ── Update ──
function update() {
  for (const s of ships) updateShip(s);
  setThrusterOn(ships.some(s => s.thrusting));

  // Lasers
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    l.x += l.vx; l.y += l.vy; l.life--;
    if (l.life <= 0) { lasers.splice(i, 1); continue; }
    for (let j = asteroids.length - 1; j >= 0; j--) {
      const a = asteroids[j];
      if (Math.hypot(l.x - a.x, l.y - a.y) < a.radius) {
        a.hp -= l.damage;
        lasers.splice(i, 1);
        spawnParticles(l.x, l.y, ORE_TYPES[a.type].color, 4, 1.5);
        if (a.hp <= 0) destroyAsteroid(a, j, l.owner);
        else sfxHit();
        break;
      }
    }
  }

  // Asteroids
  for (const a of asteroids) { a.x += a.vx; a.y += a.vy; a.rotation += a.rotSpeed; }

  // Ship vs asteroid
  for (const s of ships) {
    if (!s.alive || s.invuln > 0) continue;
    for (const a of asteroids) {
      if (Math.hypot(s.x - a.x, s.y - a.y) < SHIP_RADIUS + a.radius) {
        damageShip(s, a.size === 'large' ? 2 : 1, a.x, a.y);
        break;
      }
    }
  }

  // Ore drops
  for (let i = oreDrops.length - 1; i >= 0; i--) {
    const o = oreDrops[i];
    o.x += o.vx; o.y += o.vy; o.vx *= 0.99; o.vy *= 0.99; o.life--;
    if (o.life <= 0) { oreDrops.splice(i, 1); continue; }

    let collected = false;
    for (const s of ships) {
      if (!s.alive) continue;
      const range = BASE_ORE_RANGE + s.upgrades.magnet * 15;
      const dist = Math.hypot(o.x - s.x, o.y - s.y);

      // Magnet pull effect
      if (s.upgrades.magnet > 0 && dist < range * 2.5) {
        const pull = 0.3 * s.upgrades.magnet;
        o.vx += ((s.x - o.x) / dist) * pull;
        o.vy += ((s.y - o.y) / dist) * pull;
      }

      if (dist < range) {
        s.ore += o.value;
        oreDrops.splice(i, 1);
        sfxOre();
        collected = true;
        break;
      }
    }
    if (!collected) {
      for (const b of botShips) {
        if (!b.alive) continue;
        const range = BASE_ORE_RANGE + b.upgrades.magnet * 15;
        const dist = Math.hypot(o.x - b.x, o.y - b.y);
        if (b.upgrades.magnet > 0 && dist < range * 2.5) {
          const pull = 0.3 * b.upgrades.magnet;
          o.vx += ((b.x - o.x) / dist) * pull;
          o.vy += ((b.y - o.y) / dist) * pull;
        }
        if (dist < range) { b.ore += o.value; oreDrops.splice(i, 1); collected = true; break; }
      }
    }
  }

  // Alien bases: rotate
  for (const b of alienBases) {
    b.angle += 0.01;
    if (b.flashTimer > 0) b.flashTimer--;
  }

  // Alien projectiles: move + hit ships
  for (let i = alienProjectiles.length - 1; i >= 0; i--) {
    const p = alienProjectiles[i];
    p.x += p.vx; p.y += p.vy;
    for (const s of ships) {
      if (!s.alive || s.invuln > 0) continue;
      if (Math.hypot(p.x - s.x, p.y - s.y) < SHIP_RADIUS + 4) {
        damageShip(s, 1, p.x, p.y);
        alienProjectiles.splice(i, 1);
        sfxAlienHit();
        break;
      }
    }
  }

  // Lasers vs alien bases (only player lasers)
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    if (l.isBot) continue;
    for (let j = alienBases.length - 1; j >= 0; j--) {
      const b = alienBases[j];
      if (Math.hypot(l.x - b.x, l.y - b.y) < b.radius) {
        b.hp -= l.damage;
        b.flashTimer = 6;
        lasers.splice(i, 1);
        spawnParticles(l.x, l.y, '#0f0', 5, 1.5);
        if (b.hp <= 0) {
          // Destroyed: drop lots of ore
          spawnParticles(b.x, b.y, '#0f0', 20, 3);
          spawnParticles(b.x, b.y, '#0a0', 15, 2);
          for (let k = 0; k < 5; k++) {
            oreDrops.push({
              x: b.x + (Math.random() - 0.5) * 20,
              y: b.y + (Math.random() - 0.5) * 20,
              vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
              type: Math.random() < 0.3 ? 2 : 1, value: 3 + Math.floor(Math.random() * 4),
              life: 600
            });
          }
          alienBases.splice(j, 1);
          sfxBreak();
        } else { sfxHit(); }
        break;
      }
    }
  }

  // Update bot ships (rival miners)
  for (const b of botShips) updateBotShip(b);

  // Bot vs asteroid collision
  for (const b of botShips) {
    if (!b.alive || b.invuln > 0) continue;
    for (const a of asteroids) {
      if (Math.hypot(b.x - a.x, b.y - a.y) < SHIP_RADIUS + a.radius) {
        damageBotShip(b, a.size === 'large' ? 2 : 1, a.x, a.y);
        break;
      }
    }
  }

  // Bot lasers vs player ships
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    if (!l.isBot) continue;
    let hit = false;
    for (const s of ships) {
      if (!s.alive || s.invuln > 0) continue;
      if (Math.hypot(l.x - s.x, l.y - s.y) < SHIP_RADIUS) {
        damageShip(s, l.damage, l.x, l.y);
        lasers.splice(i, 1); hit = true; sfxAlienHit(); break;
      }
    }
    if (hit) continue;
    // Bot lasers vs other bots
    for (const b of botShips) {
      if (!b.alive || b.invuln > 0 || b === l.botRef) continue;
      if (Math.hypot(l.x - b.x, l.y - b.y) < SHIP_RADIUS) {
        damageBotShip(b, l.damage, l.x, l.y);
        lasers.splice(i, 1); sfxHit(); break;
      }
    }
  }

  // Player lasers vs bot ships
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    if (l.isBot) continue;
    for (const b of botShips) {
      if (!b.alive || b.invuln > 0) continue;
      if (Math.hypot(l.x - b.x, l.y - b.y) < SHIP_RADIUS) {
        damageBotShip(b, l.damage, l.x, l.y, true);
        lasers.splice(i, 1); spawnParticles(l.x, l.y, b.color, 4, 1.5); sfxHit(); break;
      }
    }
  }

  // Ship vs bot ship collision
  for (const s of ships) {
    if (!s.alive || s.invuln > 0) continue;
    for (const b of botShips) {
      if (!b.alive || b.invuln > 0) continue;
      if (Math.hypot(s.x - b.x, s.y - b.y) < SHIP_RADIUS * 2) {
        damageShip(s, 1, b.x, b.y);
        damageBotShip(b, 1, s.x, s.y, true);
        break;
      }
    }
  }

  // Player vs player (2P mode)
  if (mode === '2P') {
    // Player lasers vs other player
    for (let i = lasers.length - 1; i >= 0; i--) {
      const l = lasers[i];
      if (l.isBot) continue;
      for (const s of ships) {
        if (!s.alive || s.invuln > 0 || s.num === l.owner) continue;
        if (Math.hypot(l.x - s.x, l.y - s.y) < SHIP_RADIUS) {
          damageShip(s, l.damage, l.x, l.y);
          lasers.splice(i, 1); sfxHit(); break;
        }
      }
    }
    // Player ship collision
    const s1 = ships[0], s2 = ships[1];
    if (s1.alive && s2.alive && s1.invuln <= 0 && s2.invuln <= 0) {
      if (Math.hypot(s1.x - s2.x, s1.y - s2.y) < SHIP_RADIUS * 2) {
        damageShip(s1, 1, s2.x, s2.y);
        damageShip(s2, 1, s1.x, s1.y);
      }
    }
  }

  // Lasers damage stations (bots hit any station, players hit enemy stations)
  for (const st of stations) {
    if (st.destroyed) continue;
    for (let i = lasers.length - 1; i >= 0; i--) {
      const l = lasers[i];
      if (!l.isBot && l.owner === st.owner) continue; // don't hit own station
      if (Math.hypot(l.x - st.x, l.y - st.y) < STATION_RADIUS) {
        st.hp--; lasers.splice(i, 1);
        spawnParticles(l.x, l.y, '#fa0', 4, 1.5);
        screenShake = Math.max(screenShake, 3);
      }
    }
    for (let i = alienProjectiles.length - 1; i >= 0; i--) {
      const p = alienProjectiles[i];
      if (Math.hypot(p.x - st.x, p.y - st.y) < STATION_RADIUS) {
        st.hp--; alienProjectiles.splice(i, 1);
        spawnParticles(p.x, p.y, '#fa0', 4, 1.5);
        screenShake = Math.max(screenShake, 3);
      }
    }
    if (st.hp <= 0) {
      st.hp = 0; st.destroyed = true;
      spawnParticles(st.x, st.y, '#f80', 30, 4);
      spawnParticles(st.x, st.y, st.color, 20, 3);
      screenShake = 15;
    }
  }

  // Chunk management
  for (const s of ships) { if (s.alive) spawnChunksFor(s); }
  if (Math.random() < 0.01) cleanupFar();

  stationAngle += 0.005;
  updateParticles();
  if (screenShake > 0) screenShake *= 0.85;
}

function destroyAsteroid(a, idx, ownerNum) {
  sfxBreak();
  spawnParticles(a.x, a.y, ORE_TYPES[a.type].color, 10, 2);
  const dc = a.size === 'large' ? 3 : a.size === 'medium' ? 2 : 1;
  for (let k = 0; k < dc; k++) {
    const ang = Math.random() * Math.PI * 2;
    oreDrops.push({ x: a.x + Math.cos(ang) * 10, y: a.y + Math.sin(ang) * 10, vx: Math.cos(ang) * 0.5 + a.vx, vy: Math.sin(ang) * 0.5 + a.vy, value: ORE_TYPES[a.type].value, color: ORE_TYPES[a.type].dropColor, life: ORE_LIFE });
  }
  if (a.size === 'large') for (let k = 0; k < 2; k++) spawnAsteroid(a.x + (Math.random() - 0.5) * 20, a.y + (Math.random() - 0.5) * 20, 'medium', a.type);
  else if (a.size === 'medium') for (let k = 0; k < 2; k++) spawnAsteroid(a.x + (Math.random() - 0.5) * 10, a.y + (Math.random() - 0.5) * 10, 'small', a.type);
  asteroids.splice(idx, 1);
}

// ── Shop ──
const REPAIR_COST = 20;
function updateShopFor(s) {
  if (s.shopOpenCd > 0) { s.shopOpenCd--; return; }
  const k = getShipKeys(s.num);
  const upKeys = Object.keys(UPGRADES);
  const totalItems = upKeys.length + 1; // upgrades + repair

  if (keyPressed(k.up) || (s.num === 1 && keyPressed('KeyW')) || (s.num === 2 && keyPressed('ArrowUp'))) {
    s.shopSelection = (s.shopSelection - 1 + totalItems) % totalItems;
  }
  if (keyPressed(k.down) || (s.num === 1 && keyPressed('KeyS')) || (s.num === 2 && keyPressed('ArrowDown'))) {
    s.shopSelection = (s.shopSelection + 1) % totalItems;
  }
  if (keyPressed(k.shoot) || (s.num === 1 && keyPressed('Space')) || (s.num === 2 && keyPressed('Enter'))) {
    if (s.shopSelection < upKeys.length) {
      const key = upKeys[s.shopSelection];
      const level = s.upgrades[key];
      if (level < 3) {
        const cost = UPGRADES[key].costs[level];
        if (s.money >= cost) {
          s.money -= cost;
          s.upgrades[key]++;
          applyUpgrade(s, key);
          sfxUpgrade();
        }
      }
    } else {
      // Repair
      if (s.hp < s.maxHp && s.money >= REPAIR_COST) {
        s.money -= REPAIR_COST;
        s.hp = s.maxHp;
        sfxUpgrade();
      }
    }
  }
  if (keyPressed(k.dock) || keyPressed('Escape')) {
    s.inShop = false;
  }
}

function applyUpgrade(s, key) {
  if (key === 'hull') { s.maxHp = 5 + s.upgrades.hull * 2; s.hp = s.maxHp; }
  if (key === 'engine') s.thrustPower = 0.12 + s.upgrades.engine * 0.02;
  if (key === 'laser') s.laserDamage = 1 + Math.floor(s.upgrades.laser * 0.5);
  if (key === 'shield') { s.maxShield = s.upgrades.shield; s.shield = s.maxShield; }
  // rate and magnet are applied dynamically in update
}

// ── Drawing ──
let viewCam = { x: 0, y: 0 };
let viewX = 0, viewY = 0, viewW = 800, viewH = 560;

function w2s(wx, wy) {
  return { x: wx - viewCam.x + viewX + viewW / 2, y: wy - viewCam.y + viewY + viewH / 2 };
}

function drawStars() {
  for (const s of stars) {
    const px = ((s.x - viewCam.x * s.layer) % 1600 + 2400) % 1600 - 400;
    const py = ((s.y - viewCam.y * s.layer) % 1200 + 1800) % 1200 - 300;
    if (px < viewX - 5 || px > viewX + viewW + 5 || py < viewY - 5 || py > viewY + viewH + 5) continue;
    ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
    ctx.fillRect(px, py, s.size, s.size);
  }
}

function drawStations(activeShip) {
  for (const st of stations) {
    const sp = w2s(st.x, st.y);
    ctx.save();
    ctx.translate(sp.x, sp.y);
    ctx.rotate(stationAngle);
    if (st.destroyed) {
      ctx.strokeStyle = '#555'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) { const a = (i / 8) * Math.PI * 2; const r = STATION_RADIUS * (0.6 + Math.sin(i * 3) * 0.3); if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r); else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r); }
      ctx.closePath(); ctx.stroke();
      ctx.fillStyle = 'rgba(80,80,80,0.1)'; ctx.fill();
      ctx.fillStyle = '#333'; ctx.fillRect(-45, -3, 12, 6); ctx.fillRect(30, -2, 10, 4);
      ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
    } else {
      ctx.strokeStyle = st.color; ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) { const a = (i / 8) * Math.PI * 2; if (i === 0) ctx.moveTo(Math.cos(a) * STATION_RADIUS, Math.sin(a) * STATION_RADIUS); else ctx.lineTo(Math.cos(a) * STATION_RADIUS, Math.sin(a) * STATION_RADIUS); }
      ctx.closePath(); ctx.stroke();
      ctx.globalAlpha = 0.1; ctx.fillStyle = st.color; ctx.fill(); ctx.globalAlpha = 1;
      ctx.fillStyle = st.color; ctx.globalAlpha = 0.4; ctx.fillRect(-45, -4, 16, 8); ctx.fillRect(29, -4, 16, 8); ctx.globalAlpha = 1;
      ctx.fillStyle = st.color; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();

    // Station HP bar
    if (!st.destroyed && st.hp < st.maxHp) {
      const bw = 50, bh = 4;
      const hpFrac = st.hp / st.maxHp;
      ctx.fillStyle = '#300'; ctx.fillRect(sp.x - bw/2, sp.y + STATION_RADIUS + 8, bw, bh);
      ctx.fillStyle = hpFrac > 0.5 ? st.color : hpFrac > 0.25 ? '#fa0' : '#f44';
      ctx.fillRect(sp.x - bw/2, sp.y + STATION_RADIUS + 8, bw * hpFrac, bh);
    }
    if (st.destroyed) {
      ctx.fillStyle = '#f44'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('DESTROYED', sp.x, sp.y + STATION_RADIUS + 14);
    }

    // Dock prompt — only for the ship that owns this station
    if (!st.destroyed && activeShip && activeShip.alive && activeShip.station === st && Math.hypot(activeShip.x - st.x, activeShip.y - st.y) < STATION_RADIUS + 60) {
      ctx.strokeStyle = 'rgba(100,200,255,0.4)'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.arc(sp.x, sp.y, STATION_RADIUS + 40, 0, Math.PI * 2); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(100,200,255,0.7)'; ctx.font = '11px sans-serif'; ctx.textAlign = 'center';
      const dockKey = activeShip.num === 1 ? 'E' : 'RShift';
      ctx.fillText(`Press ${dockKey} to dock`, sp.x, sp.y + STATION_RADIUS + 55);
    }

    // Owner label in 2P
    if (mode === '2P' && !st.destroyed) {
      ctx.fillStyle = st.color; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(`P${st.owner}`, sp.x, sp.y - STATION_RADIUS - 8);
    }
  }
}

function drawShipAt(s) {
  const sp = w2s(s.x, s.y);
  if (s.invuln > 0 && Math.floor(s.invuln / 4) % 2 === 0) return;

  // Shield glow
  if (s.shield >= 1) {
    ctx.strokeStyle = `rgba(80,200,255,${0.3 + Math.sin(Date.now() * 0.005) * 0.1})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(sp.x, sp.y, SHIP_RADIUS + 5, 0, Math.PI * 2); ctx.stroke();
  }

  ctx.save();
  ctx.translate(sp.x, sp.y);
  ctx.rotate(s.angle);
  if (s.thrusting) {
    ctx.fillStyle = '#f80'; ctx.beginPath(); ctx.moveTo(-10, -4); ctx.lineTo(-16 - Math.random() * 8, 0); ctx.lineTo(-10, 4); ctx.fill();
    ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.moveTo(-10, -2); ctx.lineTo(-13 - Math.random() * 5, 0); ctx.lineTo(-10, 2); ctx.fill();
  }
  ctx.fillStyle = s.color; ctx.strokeStyle = s.cockpitColor; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(16, 0); ctx.lineTo(-10, -9); ctx.lineTo(-6, 0); ctx.lineTo(-10, 9); ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.fillStyle = s.cockpitColor; ctx.beginPath(); ctx.arc(4, 0, 3, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

function drawAsteroids() {
  for (const a of asteroids) {
    const sp = w2s(a.x, a.y);
    if (sp.x < viewX - 80 || sp.x > viewX + viewW + 80 || sp.y < viewY - 80 || sp.y > viewY + viewH + 80) continue;
    ctx.save(); ctx.translate(sp.x, sp.y); ctx.rotate(a.rotation);
    ctx.fillStyle = ORE_TYPES[a.type].color; ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < a.verts.length; i++) { if (i === 0) ctx.moveTo(a.verts[i].x, a.verts[i].y); else ctx.lineTo(a.verts[i].x, a.verts[i].y); }
    ctx.closePath(); ctx.fill(); ctx.stroke();
    if (a.hp < a.maxHp) {
      ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
      for (let i = 0; i < Math.ceil((1 - a.hp / a.maxHp) * 3); i++) { ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(a.verts[i % a.verts.length].x * 0.8, a.verts[i % a.verts.length].y * 0.8); ctx.stroke(); }
    }
    ctx.restore();
  }
}

function drawLasers() {
  for (const l of lasers) {
    const sp = w2s(l.x, l.y);
    ctx.strokeStyle = l.color; ctx.lineWidth = 2;
    const ang = Math.atan2(l.vy, l.vx);
    ctx.beginPath(); ctx.moveTo(sp.x - Math.cos(ang) * 10, sp.y - Math.sin(ang) * 10); ctx.lineTo(sp.x, sp.y); ctx.stroke();
  }
}

function drawAlienBases() {
  for (const b of alienBases) {
    const sp = w2s(b.x, b.y);
    if (sp.x < viewX - 40 || sp.x > viewX + viewW + 40 || sp.y < viewY - 40 || sp.y > viewY + viewH + 40) continue;
    // Detection range ring
    const nearShip = ships.some(s => s.alive && Math.hypot(s.x - b.x, s.y - b.y) < b.range);
    if (nearShip) {
      ctx.strokeStyle = 'rgba(255,0,0,0.08)'; ctx.lineWidth = 1;
      // Scale range to screen (approximate)
      ctx.beginPath(); ctx.arc(sp.x, sp.y, b.range * (viewW / 800), 0, Math.PI * 2); ctx.stroke();
    }
    const botColor = b.botShip ? b.botShip.color : '#0f0';
    // Base glow
    ctx.fillStyle = b.flashTimer > 0 ? 'rgba(255,255,100,0.15)' : (botColor + '18');
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 28, 0, Math.PI * 2); ctx.fill();
    // Base body: hexagon
    ctx.fillStyle = b.flashTimer > 0 ? '#4a4' : '#1a1a2a';
    ctx.strokeStyle = botColor; ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const a = b.angle + i * Math.PI / 3;
      const px = sp.x + Math.cos(a) * b.radius, py = sp.y + Math.sin(a) * b.radius;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath(); ctx.fill(); ctx.stroke();
    // Inner eye
    ctx.fillStyle = nearShip ? '#f00' : botColor;
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 5, 0, Math.PI * 2); ctx.fill();
    // HP bar
    if (b.hp < b.maxHp) {
      const bw = 30, bh = 3;
      ctx.fillStyle = '#300'; ctx.fillRect(sp.x - bw/2, sp.y - b.radius - 8, bw, bh);
      ctx.fillStyle = botColor; ctx.fillRect(sp.x - bw/2, sp.y - b.radius - 8, bw * (b.hp / b.maxHp), bh);
    }
  }
}

function drawAlienProjectiles() {
  ctx.fillStyle = '#0f0';
  for (const p of alienProjectiles) {
    const sp = w2s(p.x, p.y);
    // Glow
    ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 5, 0, Math.PI * 2); ctx.fill();
    // Core
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#4f4';
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#0f0';
  }
  ctx.globalAlpha = 1;
}

function drawBotShips() {
  for (const b of botShips) {
    if (!b.alive) continue;
    drawShipAt(b);
    const sp0 = w2s(b.x, b.y);
    // Name tag above bot
    ctx.fillStyle = b.color; ctx.font = '8px sans-serif'; ctx.textAlign = 'center'; ctx.globalAlpha = 0.7;
    ctx.fillText(b.name, sp0.x, sp0.y - (b.hp < b.maxHp ? 24 : 20));
    ctx.globalAlpha = 1;
    // Angry indicator when seeking revenge
    if (b.state === 'revenge') {
      ctx.fillStyle = '#f44'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('!', sp0.x + ctx.measureText(b.name).width / 2 + 6, sp0.y - (b.hp < b.maxHp ? 24 : 20));
      ctx.strokeStyle = 'rgba(255,50,50,0.4)'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.arc(sp0.x, sp0.y, SHIP_RADIUS + 4, 0, Math.PI * 2); ctx.stroke();
    }
    // HP bar above bot
    if (b.hp < b.maxHp) {
      const bw = 22, bh = 3;
      ctx.fillStyle = '#300'; ctx.fillRect(sp0.x - bw/2, sp0.y - 18, bw, bh);
      ctx.fillStyle = b.color; ctx.fillRect(sp0.x - bw/2, sp0.y - 18, bw * (b.hp / b.maxHp), bh);
    }
    // Upgrade level indicators (small dots below ship)
    const sp = w2s(b.x, b.y);
    const totalUpgrades = Object.values(b.upgrades).reduce((a, v) => a + v, 0);
    if (totalUpgrades > 0) {
      ctx.fillStyle = b.color; ctx.globalAlpha = 0.6;
      for (let i = 0; i < Math.min(totalUpgrades, 8); i++) {
        ctx.beginPath(); ctx.arc(sp.x - (totalUpgrades - 1) * 2.5 + i * 5, sp.y + 16, 1.5, 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
  }
}

function drawOreDrops() {
  for (const o of oreDrops) {
    const sp = w2s(o.x, o.y);
    if (sp.x < viewX - 20 || sp.x > viewX + viewW + 20 || sp.y < viewY - 20 || sp.y > viewY + viewH + 20) continue;
    const alpha = Math.min(1, o.life / 60), pulse = 1 + Math.sin(o.life * 0.15) * 0.2;
    ctx.globalAlpha = alpha; ctx.fillStyle = o.color;
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 4 * pulse, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = alpha * 0.3;
    ctx.beginPath(); ctx.arc(sp.x, sp.y, 8 * pulse, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawParticlesWorld() {
  for (const p of particles) {
    const sp = w2s(p.x, p.y);
    ctx.globalAlpha = p.life / p.maxLife; ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(sp.x, sp.y, p.size, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function getStandings() {
  const list = [];
  for (const s of ships) list.push({ color: s.color, money: s.money, isPlayer: true, num: s.num, alive: s.alive });
  for (const b of botShips) list.push({ color: b.color, money: b.money, isPlayer: false, alive: b.alive, name: b.name });
  list.sort((a, b) => b.money - a.money);
  return list;
}

function drawHUDFor(s) {
  const hx = viewX + 8, hy = viewY + 8;
  const barW = Math.min(130, viewW - 20);

  // HP
  ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(hx, hy, barW + 4, 16);
  ctx.fillStyle = '#400'; ctx.fillRect(hx + 2, hy + 2, barW, 12);
  const hpPct = Math.max(0, s.hp) / s.maxHp;
  ctx.fillStyle = hpPct > 0.5 ? '#4a4' : hpPct > 0.25 ? '#da4' : '#d44';
  ctx.fillRect(hx + 2, hy + 2, barW * hpPct, 12);
  ctx.strokeStyle = '#666'; ctx.lineWidth = 1; ctx.strokeRect(hx + 2, hy + 2, barW, 12);
  ctx.fillStyle = '#fff'; ctx.font = 'bold 9px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(`HP ${s.hp}/${s.maxHp}`, hx + 2 + barW / 2, hy + 12);

  // Shield bar
  if (s.maxShield > 0) {
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(hx, hy + 18, barW + 4, 10);
    ctx.fillStyle = '#024'; ctx.fillRect(hx + 2, hy + 20, barW, 6);
    ctx.fillStyle = '#4df'; ctx.fillRect(hx + 2, hy + 20, barW * (s.shield / s.maxShield), 6);
  }

  // Ore + distance
  const topRight = viewX + viewW - 8;
  ctx.textAlign = 'right'; ctx.font = 'bold 13px sans-serif';
  ctx.fillStyle = '#4f8'; ctx.fillText(`$${s.money}`, topRight, hy + 13);
  ctx.fillStyle = '#fe4'; ctx.fillText(`Ore: ${s.ore}`, topRight, hy + 26);
  ctx.font = '10px sans-serif'; ctx.fillStyle = '#8af';
  ctx.fillText(`Stn: ${Math.round(Math.hypot(s.x - s.station.x, s.y - s.station.y))}m`, topRight, hy + 39);

  // Player label in 2P
  if (mode === '2P') {
    ctx.textAlign = 'left'; ctx.font = 'bold 10px sans-serif';
    ctx.fillStyle = s.color;
    ctx.fillText(`P${s.num}`, hx, hy + (s.maxShield > 0 ? 40 : 30));
  }

  // Minimap
  const mmW = Math.min(90, viewW * 0.22), mmH = mmW;
  const mmX = viewX + viewW - mmW - 6, mmY = viewY + viewH - mmH - 6;
  const mmScale = 0.035;
  ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(mmX, mmY, mmW, mmH);
  ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.strokeRect(mmX, mmY, mmW, mmH);
  const mmCx = mmX + mmW / 2, mmCy = mmY + mmH / 2;

  // Stations on minimap
  for (const st of stations) {
    const stx = mmCx + (st.x - s.x) * mmScale, sty = mmCy + (st.y - s.y) * mmScale;
    const stCol = st.destroyed ? '#555' : st.color;
    if (stx >= mmX && stx <= mmX + mmW && sty >= mmY && sty <= mmY + mmH) {
      ctx.fillStyle = stCol; ctx.beginPath(); ctx.arc(stx, sty, 2.5, 0, Math.PI * 2); ctx.fill();
    } else {
      const ang = Math.atan2(st.y - s.y, st.x - s.x);
      const ax = mmCx + Math.cos(ang) * (mmW / 2 - 8), ay = mmCy + Math.sin(ang) * (mmH / 2 - 8);
      ctx.fillStyle = stCol; ctx.beginPath();
      ctx.moveTo(ax + Math.cos(ang) * 5, ay + Math.sin(ang) * 5);
      ctx.lineTo(ax + Math.cos(ang + 2.5) * 4, ay + Math.sin(ang + 2.5) * 4);
      ctx.lineTo(ax + Math.cos(ang - 2.5) * 4, ay + Math.sin(ang - 2.5) * 4);
      ctx.closePath(); ctx.fill();
    }
  }

  // Other ships on minimap
  for (const other of ships) {
    if (other === s || !other.alive) continue;
    const ox = mmCx + (other.x - s.x) * mmScale, oy = mmCy + (other.y - s.y) * mmScale;
    if (ox >= mmX && ox <= mmX + mmW && oy >= mmY && oy <= mmY + mmH) {
      ctx.fillStyle = other.color; ctx.beginPath(); ctx.arc(ox, oy, 2, 0, Math.PI * 2); ctx.fill();
    }
  }

  // Asteroids on minimap
  for (const a of asteroids) {
    const ax = mmCx + (a.x - s.x) * mmScale, ay = mmCy + (a.y - s.y) * mmScale;
    if (ax >= mmX && ax <= mmX + mmW && ay >= mmY && ay <= mmY + mmH) {
      ctx.fillStyle = ORE_TYPES[a.type].color; ctx.globalAlpha = 0.4; ctx.fillRect(ax - 1, ay - 1, 2, 2); ctx.globalAlpha = 1;
    }
  }

  // Alien bases on minimap
  for (const b of alienBases) {
    const bx = mmCx + (b.x - s.x) * mmScale, by = mmCy + (b.y - s.y) * mmScale;
    if (bx >= mmX && bx <= mmX + mmW && by >= mmY && by <= mmY + mmH) {
      ctx.fillStyle = b.botShip ? b.botShip.color : '#0f0'; ctx.globalAlpha = 0.8; ctx.fillRect(bx - 2, by - 2, 4, 4); ctx.globalAlpha = 1;
    }
  }

  // Bot ships on minimap
  for (const b of botShips) {
    if (!b.alive) continue;
    const bx = mmCx + (b.x - s.x) * mmScale, by = mmCy + (b.y - s.y) * mmScale;
    if (bx >= mmX && bx <= mmX + mmW && by >= mmY && by <= mmY + mmH) {
      ctx.fillStyle = b.color; ctx.globalAlpha = 0.9;
      ctx.beginPath(); ctx.arc(bx, by, 2, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Self on minimap
  ctx.fillStyle = s.color; ctx.beginPath(); ctx.arc(mmCx, mmCy, 2, 0, Math.PI * 2); ctx.fill();

  // Compass arrows pointing to each bot — spread overlapping arrows
  const compassArrows = [];
  for (const b of botShips) {
    if (!b.alive) continue;
    const bp = w2s(b.x, b.y);
    if (bp.x >= viewX + 20 && bp.x <= viewX + viewW - 20 && bp.y >= viewY + 20 && bp.y <= viewY + viewH - 20) continue;
    const ang = Math.atan2(b.y - s.y, b.x - s.x);
    const margin = 18;
    const ccx = viewX + viewW / 2, ccy = viewY + viewH / 2;
    const hw = viewW / 2 - margin, hh = viewH / 2 - margin;
    const scale = Math.min(hw / Math.abs(Math.cos(ang) || 0.001), hh / Math.abs(Math.sin(ang) || 0.001));
    let ax = ccx + Math.cos(ang) * scale, ay = ccy + Math.sin(ang) * scale;
    // Push apart from existing arrows
    for (const prev of compassArrows) {
      if (Math.hypot(ax - prev.x, ay - prev.y) < 14) {
        const perp = ang + Math.PI / 2;
        ax += Math.cos(perp) * 14; ay += Math.sin(perp) * 14;
      }
    }
    compassArrows.push({ x: ax, y: ay });
    const angry = b.state === 'revenge';
    ctx.save(); ctx.translate(ax, ay); ctx.rotate(ang);
    ctx.fillStyle = angry ? '#f44' : b.color; ctx.globalAlpha = 0.85;
    ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(-5, -5); ctx.lineTo(-2, 0); ctx.lineTo(-5, 5); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.6; ctx.font = '8px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText((angry ? '! ' : '') + b.name + ' ' + Math.round(Math.hypot(b.x - s.x, b.y - s.y)) + 'm', 0, -9);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Compass arrows pointing to other players
  if (mode === '2P') {
    for (const other of ships) {
      if (other === s || !other.alive) continue;
      const op = w2s(other.x, other.y);
      if (op.x >= viewX + 20 && op.x <= viewX + viewW - 20 && op.y >= viewY + 20 && op.y <= viewY + viewH - 20) continue;
      const ang = Math.atan2(other.y - s.y, other.x - s.x);
      const margin = 18;
      const cx = viewX + viewW / 2, cy = viewY + viewH / 2;
      const hw = viewW / 2 - margin, hh = viewH / 2 - margin;
      const scale = Math.min(hw / Math.abs(Math.cos(ang) || 0.001), hh / Math.abs(Math.sin(ang) || 0.001));
      const ax = cx + Math.cos(ang) * scale, ay = cy + Math.sin(ang) * scale;
      ctx.save(); ctx.translate(ax, ay); ctx.rotate(ang);
      ctx.fillStyle = other.color; ctx.globalAlpha = 0.9;
      ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(-5, -5); ctx.lineTo(-2, 0); ctx.lineTo(-5, 5); ctx.closePath(); ctx.fill();
      ctx.globalAlpha = 0.6; ctx.font = 'bold 9px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('P' + other.num + ' ' + Math.round(Math.hypot(other.x - s.x, other.y - s.y)) + 'm', 0, -9);
      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  // Leaderboard
  const standings = getStandings();
  if (standings.length > 1) {
    const lbX = viewX + 6, lbY = viewY + viewH - mmH - 16 - Math.min(standings.length, 6) * 14;
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(lbX, lbY - 14, 100, Math.min(standings.length, 6) * 14 + 16);
    ctx.textAlign = 'left'; ctx.font = 'bold 9px sans-serif'; ctx.fillStyle = '#8af';
    ctx.fillText('LEADERBOARD', lbX + 4, lbY - 3);
    ctx.font = '10px sans-serif';
    for (let i = 0; i < Math.min(standings.length, 6); i++) {
      const e = standings[i];
      const isMe = e.isPlayer && e.num === s.num;
      ctx.fillStyle = isMe ? '#fff' : (e.alive ? e.color : '#555');
      const label = e.isPlayer ? (mode === '2P' ? `P${e.num}` : 'YOU') : e.name;
      ctx.fillText(`${i + 1}. ${label}`, lbX + 4, lbY + 10 + i * 14);
      ctx.fillStyle = isMe ? '#fe4' : '#aaa';
      ctx.fillText(`$${e.money}`, lbX + 56, lbY + 10 + i * 14);
    }
  }

  ctx.textAlign = 'left';
}

function drawViewport(s, vx, vy, vw, vh) {
  viewX = vx; viewY = vy; viewW = vw; viewH = vh;
  viewCam = { x: s.x, y: s.y };

  ctx.save();
  ctx.beginPath(); ctx.rect(vx, vy, vw, vh); ctx.clip();
  ctx.fillStyle = '#000'; ctx.fillRect(vx, vy, vw, vh);

  drawStars();
  drawStations(s);
  drawOreDrops();
  drawAsteroids();
  drawAlienBases();
  drawBotShips();
  drawAlienProjectiles();
  drawLasers();
  drawParticlesWorld();
  for (const sh of ships) { if (sh.alive) drawShipAt(sh); }
  drawHUDFor(s);

  ctx.restore();
}

function drawShop(s, vx, vy, vw, vh) {
  ctx.save();
  ctx.beginPath(); ctx.rect(vx, vy, vw, vh); ctx.clip();
  ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(vx, vy, vw, vh);
  const pw = Math.min(380, vw - 20), ph = 470;
  const px = vx + (vw - pw) / 2, py = vy + (vh - ph) / 2;
  const cx = vx + vw / 2;
  ctx.fillStyle = '#0a0a2a'; ctx.strokeStyle = '#8af'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(px, py, pw, ph, 12); ctx.fill(); ctx.stroke();

  ctx.textAlign = 'center'; ctx.font = 'bold 22px sans-serif'; ctx.fillStyle = '#8af';
  ctx.fillText(mode === '2P' ? `P${s.num} SHOP` : 'STATION SHOP', cx, py + 32);
  ctx.font = '13px sans-serif'; ctx.fillStyle = '#fe4';
  ctx.fillText(`$${s.money}`, cx, py + 52);

  const upKeys = Object.keys(UPGRADES);
  for (let i = 0; i < upKeys.length; i++) {
    const key = upKeys[i], up = UPGRADES[key], level = s.upgrades[key];
    const iy = py + 65 + i * 52;
    const sel = s.shopSelection === i;

    if (sel) { ctx.fillStyle = 'rgba(100,150,255,0.12)'; ctx.fillRect(px + 12, iy - 2, pw - 24, 48); }

    ctx.textAlign = 'left'; ctx.font = 'bold 15px sans-serif'; ctx.fillStyle = sel ? '#fff' : '#aaa';
    ctx.fillText(`${up.label}`, px + 20, iy + 16);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#888';
    ctx.fillText(up.desc, px + 20, iy + 30);

    for (let j = 0; j < 3; j++) { ctx.fillStyle = j < level ? '#4f8' : '#333'; ctx.fillRect(px + 20 + j * 18, iy + 35, 14, 5); }

    ctx.textAlign = 'right'; ctx.font = '13px sans-serif';
    if (level >= 3) { ctx.fillStyle = '#4f8'; ctx.fillText('MAX', px + pw - 20, iy + 16); }
    else { const cost = up.costs[level]; ctx.fillStyle = s.money >= cost ? '#fe4' : '#844'; ctx.fillText(`$${cost}`, px + pw - 20, iy + 16); }
  }

  // Repair option
  const repairIdx = upKeys.length;
  const ry = py + 65 + repairIdx * 52;
  const rSel = s.shopSelection === repairIdx;
  if (rSel) { ctx.fillStyle = 'rgba(100,150,255,0.12)'; ctx.fillRect(px + 12, ry - 2, pw - 24, 48); }
  ctx.textAlign = 'left'; ctx.font = 'bold 15px sans-serif'; ctx.fillStyle = rSel ? '#fff' : '#aaa';
  ctx.fillText('Repair', px + 20, ry + 16);
  ctx.font = '11px sans-serif'; ctx.fillStyle = '#888';
  ctx.fillText('Restore HP to full', px + 20, ry + 30);
  // HP bar preview
  const hpFrac = s.hp / s.maxHp;
  ctx.fillStyle = '#400'; ctx.fillRect(px + 20, ry + 35, 54, 5);
  ctx.fillStyle = hpFrac > 0.5 ? '#4a4' : hpFrac > 0.25 ? '#da4' : '#d44';
  ctx.fillRect(px + 20, ry + 35, 54 * hpFrac, 5);
  ctx.textAlign = 'right'; ctx.font = '13px sans-serif';
  if (s.hp >= s.maxHp) { ctx.fillStyle = '#4f8'; ctx.fillText('FULL', px + pw - 20, ry + 16); }
  else { ctx.fillStyle = s.money >= REPAIR_COST ? '#fe4' : '#844'; ctx.fillText(`$${REPAIR_COST}`, px + pw - 20, ry + 16); }

  ctx.textAlign = 'center'; ctx.font = '11px sans-serif'; ctx.fillStyle = '#555';
  const dockKey = s.num === 1 ? 'E' : 'RShift';
  ctx.fillText(`Up/Down: Select | Shoot: Buy | ${dockKey}: Leave`, cx, py + ph - 12);
  ctx.restore();
}

// ── Menu ──
canvas.addEventListener('mousemove', e => {
  if (state !== 'menu') return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  hoverMode = mx > 300 && mx < 500 && my > 260 && my < 305;
  hoverStart = mx > 300 && mx < 500 && my > 320 && my < 370;
});

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  if (state === 'menu') {
    if (mx > 300 && mx < 500 && my > 260 && my < 305) mode = mode === '1P' ? '2P' : '1P';
    if (mx > 300 && mx < 500 && my > 320 && my < 370) initGame();
  }
});

function drawMenu() {
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Stars
  for (const s of stars) {
    ctx.fillStyle = `rgba(255,255,255,${s.brightness * 0.5})`;
    ctx.fillRect(s.x % 800 + 400, s.y % 560 + 280, s.size, s.size);
  }
  ctx.textAlign = 'center';
  ctx.font = 'bold 44px sans-serif'; ctx.fillStyle = '#8af';
  ctx.fillText('ASTEROID MINER', canvas.width / 2, 120);
  ctx.font = '16px sans-serif'; ctx.fillStyle = '#666';
  ctx.fillText('Mine. Upgrade. Survive.', canvas.width / 2, 155);

  // Mode
  ctx.fillStyle = hoverMode ? '#1a2a3a' : '#0a1a2a'; ctx.strokeStyle = '#8af'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(300, 260, 200, 42, 10); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#fff'; ctx.font = 'bold 18px sans-serif';
  ctx.fillText(mode === '1P' ? '1 Player' : '2 Players', canvas.width / 2, 288);

  // Start
  ctx.fillStyle = hoverStart ? '#1a3a1a' : '#0a2a0a'; ctx.strokeStyle = '#4f8'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(300, 320, 200, 48, 10); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#4f8'; ctx.font = 'bold 20px sans-serif';
  ctx.fillText('LAUNCH', canvas.width / 2, 351);

  ctx.font = '13px sans-serif'; ctx.fillStyle = '#555';
  ctx.fillText('P1: WASD + Space + E', canvas.width / 2, 420);
  ctx.fillText('P2: Arrows + Enter + RShift', canvas.width / 2, 440);
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.textAlign = 'center';
  ctx.font = 'bold 36px sans-serif'; ctx.fillStyle = '#f44';
  ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
  ctx.font = '18px sans-serif'; ctx.fillStyle = '#fa0';
  ctx.fillText('Your base was destroyed', canvas.width / 2, canvas.height / 2 - 20);
  ctx.fillStyle = '#f66';
  ctx.fillText('and you were destroyed', canvas.width / 2, canvas.height / 2 + 10);
  // Final standings
  const standings = getStandings();
  const startY = canvas.height / 2 + 40;
  ctx.font = 'bold 13px sans-serif'; ctx.fillStyle = '#8af';
  ctx.fillText('FINAL STANDINGS', canvas.width / 2, startY);
  ctx.font = '12px sans-serif';
  for (let i = 0; i < Math.min(standings.length, 8); i++) {
    const e = standings[i];
    ctx.fillStyle = e.isPlayer ? '#4f8' : e.color;
    const label = e.isPlayer ? (mode === '2P' ? `P${e.num}` : 'YOU') : e.name;
    ctx.fillText(`#${i + 1}  ${label} — $${e.money}`, canvas.width / 2, startY + 18 + i * 15);
  }
  ctx.font = '16px sans-serif'; ctx.fillStyle = '#8af';
  ctx.fillText('Press Space to return to menu', canvas.width / 2, startY + 30 + Math.min(standings.length, 8) * 15);
}

// ── Main Loop ──
let lastTime = 0, acc = 0;
const STEP = 1000 / 60;

function gameLoop(timestamp) {
  const elapsed = Math.min(timestamp - lastTime, 50);
  lastTime = timestamp;
  acc += elapsed;

  while (acc >= STEP) {
    acc -= STEP;
    if (state === 'playing') {
      update();
      for (const s of ships) { if (s.inShop) updateShopFor(s); }
    } else if (state === 'gameover') {
      if (keyPressed('Space')) { state = 'menu'; stopMusic(); }
    }
    copyKeys();
  }

  const shakeX = (Math.random() - 0.5) * screenShake;
  const shakeY = (Math.random() - 0.5) * screenShake;
  ctx.save(); ctx.translate(shakeX, shakeY);

  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (state === 'menu') {
    drawMenu();
  } else if (state === 'playing' || state === 'gameover') {
    if (mode === '1P') {
      drawViewport(ships[0], 0, 0, canvas.width, canvas.height);
      if (ships[0].inShop) drawShop(ships[0], 0, 0, canvas.width, canvas.height);
    } else {
      // Splitscreen
      drawViewport(ships[0], 0, 0, canvas.width / 2, canvas.height);
      drawViewport(ships[1], canvas.width / 2, 0, canvas.width / 2, canvas.height);
      // Shop overlays per-player
      if (ships[0].inShop) drawShop(ships[0], 0, 0, canvas.width / 2, canvas.height);
      if (ships[1].inShop) drawShop(ships[1], canvas.width / 2, 0, canvas.width / 2, canvas.height);
      // Divider
      ctx.strokeStyle = '#444'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke();
    }
    if (state === 'gameover') drawGameOver();
  }

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
