<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Getting Over It - Dorsey Duo</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#1a1008;overflow:hidden}
canvas{display:block}
a.back{position:fixed;top:10px;left:14px;color:#c8a060;text-decoration:none;font:14px monospace;z-index:10}
a.back:hover{text-decoration:underline}
</style>
</head>
<body>
<a class="back" href="../index.html">&larr; Back</a>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
window.addEventListener('resize', () => { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

// ── Constants ──
const GRAVITY = 500;
const MAX_SPEED = 200;
const KEY_CURSOR_SPEED = 5000; // px/s for arrow key cursor movement
const MAX_ARM_RATE = 50;       // rad/s — limits how fast the arm can spin
const ARM_LEN = 110;       // length of hammer arm
const ARM_OX = 8, ARM_OY = -10; // shoulder offset from body center
const BODY_R = 22;         // cauldron radius (collision)
const FRICTION = 0.9;      // normal velocity cancel (stops bouncing)
const SLIDE = 0.75;        // tangential velocity cancel (stops sliding)

// ── State ──
const START_X = -50, START_Y = -25;
let body = { x: START_X, y: START_Y, vx: 0, vy: 0 };
let armAngle = -Math.PI / 2;  // start pointing UP so hammer doesn't auto-plant
let prevArmAngle = -Math.PI / 2;
let grounded = false;
let pivotX = 0, pivotY = 0;
let prevHammerX = START_X + ARM_OX, prevHammerY = START_Y + ARM_OY - ARM_LEN;
// Virtual cursor — driven by arrow keys only
let cursor = { x: W / 2, y: H / 2 };
let camX = 0, camY = 0;
let highestY = START_Y; // track highest point for falling back

const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// ── Terrain ──
// Each shape: polygon { verts: [{x,y},...] }
// Y increases downward. Ground is at y=0.
function poly(pts) { return { verts: pts.map(([x,y])=>({x,y})) }; }

const terrain = [
  // Flat ground
  poly([[-800,0],[ 800,0],[ 800,200],[-800,200]]),

  // First rock cluster - gentle start
  poly([[100,-60],[320,-60],[320,-130],[260,-170],[160,-140],[80,-90]]),
  poly([[280,-75],[400,-75],[420,-180],[340,-200],[260,-140]]),

  // Angled slab
  poly([[380,-160],[520,-160],[560,-300],[420,-280]]),

  // Tall rock wall
  poly([[500,-270],[600,-250],[620,-480],[520,-500],[460,-380]]),

  // Overhang rock (tricky)
  poly([[460,-480],[620,-460],[680,-600],[560,-640],[440,-580]]),

  // Big flat boulder
  poly([[600,-580],[820,-560],[860,-700],[760,-760],[620,-720]]),

  // Narrow ledge
  poly([[800,-700],[920,-680],[940,-780],[840,-800],[780,-760]]),

  // Steep cliff face
  poly([[880,-770],[1000,-750],[1040,-980],[940,-1020],[860,-900]]),

  // Summit platform
  poly([[900,-1000],[1100,-980],[1120,-1100],[1000,-1140],[880,-1080]]),

  // Floating boulders
  poly([[1060,-1060],[1220,-1040],[1240,-1160],[1100,-1200],[1040,-1120]]),
  poly([[1180,-1150],[1340,-1120],[1360,-1260],[1220,-1300],[1160,-1220]]),

  // High ridge
  poly([[1280,-1240],[1460,-1200],[1500,-1400],[1380,-1460],[1260,-1360]]),

  // Near-peak rock
  poly([[1400,-1400],[1560,-1380],[1600,-1580],[1460,-1640],[1360,-1520]]),

  // Peak
  poly([[1520,-1560],[1660,-1520],[1680,-1700],[1540,-1760],[1480,-1640]]),
];

// ── Point-in-polygon (ray casting) ──
function pointInPoly(px, py, verts) {
  let inside = false;
  for (let i = 0, j = verts.length - 1; i < verts.length; j = i++) {
    const xi = verts[i].x, yi = verts[i].y;
    const xj = verts[j].x, yj = verts[j].y;
    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi))
      inside = !inside;
  }
  return inside;
}

// Only the flat ground (terrain[0]) is grippable — rocks are obstacles only
function hammerInGround(hx, hy) {
  return pointInPoly(hx, hy, terrain[0].verts);
}

// Segment-segment intersection — returns t along AB, or null
function segT(ax, ay, bx, by, cx, cy, dx, dy) {
  const denom = (bx-ax)*(dy-cy) - (by-ay)*(dx-cx);
  if (Math.abs(denom) < 1e-10) return null;
  const t = ((cx-ax)*(dy-cy) - (cy-ay)*(dx-cx)) / denom;
  const u = ((cx-ax)*(by-ay) - (cy-ay)*(bx-ax)) / denom;
  return (t >= 0 && t <= 1 && u >= 0 && u <= 1) ? t : null;
}

// Sweep hammer from (ax,ay)→(bx,by) — only checks flat ground (terrain[0])
function sweepHammer(ax, ay, bx, by) {
  let minT = 1, hx = null, hy = null;
  const g = terrain[0];
  for (let i = 0; i < g.verts.length; i++) {
    const v1 = g.verts[i], v2 = g.verts[(i+1)%g.verts.length];
    const tt = segT(ax, ay, bx, by, v1.x, v1.y, v2.x, v2.y);
    if (tt !== null && tt < minT) {
      minT = tt; hx = ax + tt*(bx-ax); hy = ay + tt*(by-ay);
    }
  }
  return hx !== null ? {x: hx, y: hy} : null;
}

// ── Circle vs polygon collision for body ──
// Uses closest-point-on-boundary approach — more reliable than SAT
function resolveBodyTerrain() {
  for (let iter = 0; iter < 3; iter++) {
    let any = false;
    for (const terr of terrain) {
      const verts = terr.verts;
      const nv = verts.length;
      const inside = pointInPoly(body.x, body.y, verts);

      // Find closest point on polygon boundary to body center
      let minDist = Infinity, cpx = 0, cpy = 0;
      for (let i = 0; i < nv; i++) {
        const a = verts[i], b = verts[(i+1)%nv];
        const edx = b.x-a.x, edy = b.y-a.y;
        const len2 = edx*edx+edy*edy;
        if (len2 < 1e-10) continue;
        const tp = Math.max(0, Math.min(1, ((body.x-a.x)*edx+(body.y-a.y)*edy)/len2));
        const px = a.x+tp*edx, py = a.y+tp*edy;
        const d = Math.hypot(body.x-px, body.y-py);
        if (d < minDist) { minDist=d; cpx=px; cpy=py; }
      }

      if (!inside && minDist >= BODY_R) continue;
      any = true;

      let nx, ny, pen;
      if (inside) {
        // Push toward closest boundary point and BODY_R past it
        if (minDist < 0.001) { nx = 0; ny = -1; pen = BODY_R; }
        else { nx=(cpx-body.x)/minDist; ny=(cpy-body.y)/minDist; pen=minDist+BODY_R; }
      } else {
        // Push away from closest boundary point
        if (minDist < 0.001) { nx = 0; ny = -1; pen = BODY_R - minDist; }
        else { nx=(body.x-cpx)/minDist; ny=(body.y-cpy)/minDist; pen=BODY_R-minDist; }
      }
      body.x += nx * pen;
      body.y += ny * pen;

      // Cancel velocity into surface, damp tangential
      const dot = body.vx*nx + body.vy*ny;
      if (dot < 0) {
        body.vx -= dot * nx * FRICTION;
        body.vy -= dot * ny * FRICTION;
        body.vx *= (1 - SLIDE);
        body.vy *= (1 - SLIDE);
      }
    }
    if (!any) break;
  }
}

// ── Angle helpers ──
function angleDiff(a, b) {
  let d = a - b;
  while (d > Math.PI) d -= 2 * Math.PI;
  while (d < -Math.PI) d += 2 * Math.PI;
  return d;
}

// ── Update ──
let lastT = 0;
function update(now) {
  const dt = Math.min((now - lastT) / 1000, 0.05);
  lastT = now;

  // Arrow keys move virtual cursor
  if (keys['ArrowLeft'])  cursor.x -= KEY_CURSOR_SPEED * dt;
  if (keys['ArrowRight']) cursor.x += KEY_CURSOR_SPEED * dt;
  if (keys['ArrowUp'])    cursor.y -= KEY_CURSOR_SPEED * dt;
  if (keys['ArrowDown'])  cursor.y += KEY_CURSOR_SPEED * dt;

  // World-space cursor
  const wx = cursor.x + camX;
  const wy = cursor.y + camY;

  // Shoulder position (arm origin)
  const sx = body.x + ARM_OX, sy = body.y + ARM_OY;

  // Arm angle — rate-limited so fast key movements don't cause big velocity spikes
  const targetAngle = Math.atan2(wy - sy, wx - sx);
  const maxDelta = MAX_ARM_RATE * dt;
  const rawDelta = angleDiff(targetAngle, armAngle);
  const clampedDelta = Math.max(-maxDelta, Math.min(maxDelta, rawDelta));
  prevArmAngle = armAngle;
  armAngle += clampedDelta;

  // Hammer head (from shoulder)
  const hx = sx + ARM_LEN * Math.cos(armAngle);
  const hy = sy + ARM_LEN * Math.sin(armAngle);

  // Unground when cursor rises above shoulder — user is raising the arm
  if (grounded && wy < sy) grounded = false;

  if (!grounded) {
    // Sweep hammer path for first terrain surface crossing
    const hit = sweepHammer(prevHammerX, prevHammerY, hx, hy);
    if (hit) {
      pivotX = hit.x; pivotY = hit.y; grounded = true;
    } else if (hammerInGround(hx, hy)) {
      // Already inside (large jump) — find surface by sweeping from shoulder
      const hit2 = sweepHammer(sx, sy, hx, hy);
      pivotX = hit2 ? hit2.x : hx;
      pivotY = hit2 ? hit2.y : hy;
      grounded = true;
    }
  }

  if (grounded) {
    // Body rotates around pivot
    const oldBx = body.x, oldBy = body.y;
    body.x = pivotX - ARM_LEN * Math.cos(armAngle) - ARM_OX;
    body.y = pivotY - ARM_LEN * Math.sin(armAngle) - ARM_OY;
    body.vx = (body.x - oldBx) / dt * 0.15;
    body.vy = (body.y - oldBy) / dt * 0.15;
    const spd = Math.hypot(body.vx, body.vy);
    if (spd > MAX_SPEED) { body.vx = body.vx / spd * MAX_SPEED; body.vy = body.vy / spd * MAX_SPEED; }
    // Resolve terrain, then sync armAngle to resolved position so pivot
    // formula stays consistent next frame (stops pivot vs terrain oscillation)
    const preBx = body.x, preBy = body.y;
    resolveBodyTerrain();
    if (Math.hypot(body.x - preBx, body.y - preBy) > 0.01) {
      armAngle = Math.atan2(pivotY - (body.y + ARM_OY), pivotX - (body.x + ARM_OX));
      body.vx = 0; body.vy = 0;
    }
  } else {
    // Free fall — sub-stepped to prevent tunneling through terrain
    const N = 5;
    const sdt = dt / N;
    for (let s = 0; s < N; s++) {
      body.vy += GRAVITY * sdt;
      body.x += body.vx * sdt;
      body.y += body.vy * sdt;
      // Cap speed each substep to prevent tunneling at extreme velocities
      const spd = Math.hypot(body.vx, body.vy);
      if (spd > MAX_SPEED) { body.vx = body.vx/spd*MAX_SPEED; body.vy = body.vy/spd*MAX_SPEED; }
      resolveBodyTerrain();
    }
    body.vx *= 0.995;
  }

  // Track hammer position for next frame's sweep
  const nsx = body.x + ARM_OX, nsy = body.y + ARM_OY;
  prevHammerX = nsx + ARM_LEN * Math.cos(armAngle);
  prevHammerY = nsy + ARM_LEN * Math.sin(armAngle);

  // Reset if fallen below ground
  if (body.y > 300) {
    // Fall back to highest point reached, or start
    const resetY = highestY < START_Y - 100 ? highestY + 200 : START_Y;
    body.x = START_X; body.y = Math.min(resetY, START_Y);
    body.vx = 0; body.vy = 0;
    grounded = false;
  }
  if (body.y < highestY) highestY = body.y;

  // Camera: smoothly follow body
  const targetCX = body.x - W * 0.35;
  const targetCY = body.y - H * 0.55;
  camX += (targetCX - camX) * 0.12;
  camY += (targetCY - camY) * 0.12;
}

// ── Draw ──
function drawTerrain() {
  ctx.fillStyle = '#5c3d1e';
  ctx.strokeStyle = '#3a2510';
  ctx.lineWidth = 2;
  for (const t of terrain) {
    ctx.beginPath();
    ctx.moveTo(t.verts[0].x, t.verts[0].y);
    for (let i = 1; i < t.verts.length; i++) ctx.lineTo(t.verts[i].x, t.verts[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Surface highlight
    ctx.save();
    ctx.clip();
    ctx.strokeStyle = 'rgba(200,160,80,0.18)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(t.verts[0].x, t.verts[0].y);
    for (let i = 1; i < t.verts.length; i++) ctx.lineTo(t.verts[i].x, t.verts[i].y);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
}

function drawCharacter() {
  const bx = body.x, by = body.y;
  // Shoulder = arm origin (matches physics)
  const shoulderX = bx + ARM_OX, shoulderY = by + ARM_OY;
  const hx = shoulderX + ARM_LEN * Math.cos(armAngle);
  const hy = shoulderY + ARM_LEN * Math.sin(armAngle);

  // Hammer pole
  ctx.strokeStyle = '#8b6914';
  ctx.lineWidth = 5;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(shoulderX, shoulderY);
  ctx.lineTo(hx, hy);
  ctx.stroke();

  // Hammer head (T-shape)
  const perpX = -(hy - shoulderY), perpY = (hx - shoulderX);
  const perpLen = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
  const pnx = perpX / perpLen, pny = perpY / perpLen;
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(hx - pnx * 18, hy - pny * 18);
  ctx.lineTo(hx + pnx * 18, hy + pny * 18);
  ctx.stroke();
  // Hammer head face
  ctx.fillStyle = '#aaa';
  ctx.beginPath();
  ctx.arc(hx, hy, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Cauldron body (orange-brown like original)
  const cg = ctx.createLinearGradient(bx - 28, by, bx + 28, by + 40);
  cg.addColorStop(0, '#c84010');
  cg.addColorStop(0.5, '#e05020');
  cg.addColorStop(1, '#803010');
  ctx.fillStyle = cg;
  ctx.beginPath();
  ctx.ellipse(bx, by + 14, 28, 24, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#601808';
  ctx.lineWidth = 2;
  ctx.stroke();
  // Cauldron rim
  ctx.fillStyle = '#d06020';
  ctx.beginPath();
  ctx.ellipse(bx, by - 6, 28, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#a04010';
  ctx.lineWidth = 2;
  ctx.stroke();
  // Cauldron legs
  ctx.strokeStyle = '#601808';
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  for (const [lx, ly] of [[-14, 36],[0, 40],[14, 36]]) {
    ctx.beginPath();
    ctx.moveTo(bx + lx * 0.7, by + ly - 4);
    ctx.lineTo(bx + lx, by + ly);
    ctx.stroke();
  }

  // Man sitting in cauldron
  // Body
  ctx.fillStyle = '#3a6ab0';
  ctx.beginPath();
  ctx.ellipse(bx, by - 2, 14, 18, 0, 0, Math.PI * 2);
  ctx.fill();
  // Head
  ctx.fillStyle = '#d4a070';
  ctx.beginPath();
  ctx.arc(bx + 4, by - 22, 13, 0, Math.PI * 2);
  ctx.fill();
  // Beard
  ctx.fillStyle = '#888';
  ctx.beginPath();
  ctx.ellipse(bx + 4, by - 13, 8, 6, 0, 0, Math.PI);
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(bx, by - 24, 2, 0, Math.PI * 2);
  ctx.arc(bx + 8, by - 24, 2, 0, Math.PI * 2);
  ctx.fill();

  // Pivot indicator when grounded
  if (grounded) {
    ctx.strokeStyle = 'rgba(255,220,80,0.7)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pivotX - camX, pivotY - camY, 8, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function draw() {
  // Sky gradient
  const sk = ctx.createLinearGradient(0, 0, 0, H);
  sk.addColorStop(0, '#0a0612');
  sk.addColorStop(1, '#1a0c08');
  ctx.fillStyle = sk;
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  ctx.translate(-camX, -camY);
  drawTerrain();
  drawCharacter();
  ctx.restore();

  // Height HUD
  const meters = Math.max(0, Math.floor(-body.y / 40));
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(W - 110, 10, 100, 32);
  ctx.fillStyle = '#c8a060';
  ctx.font = 'bold 16px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(meters + ' m', W - 60, 31);
}

function loop(now) {
  update(now);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
